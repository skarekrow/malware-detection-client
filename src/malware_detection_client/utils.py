import os
import sys
import json
import jwt
import base64
from datetime import datetime
import subprocess
import logging
import requests
from socket import gethostname
from urllib3.util import Retry

logging.basicConfig(format="%(asctime)s:%(levelname)s:%(message)s")
logger = logging.getLogger('malware_detection_client')
logger.setLevel(logging.getLevelName('INFO'))

CONF_FILE_TEMPLATE = """# Where values are provided for the options, these are the defaults

[client]
# Client log level.  Valid options are DEBUG, INFO, WARNING, ERROR, CRITICAL
#log_level=INFO

# Scan the files on this system?
#scan_filesystem=True

# Scan the processes on this system?
#scan_processes=True

# Add extra metadata to each scan match, eg file type, file md5sum, matching line numbers, process name
#metadata=True

# Location of the rules.  Can be any of:
# - the name of a file on the local filesystem containing rules
# - a URL for an endpoint to download a list of rules via GraphQL
# - a URL to download a file containing rules
#rules_location=/tmp/malware_detection_rules.yar
#rules_location=http://127.0.0.1:3000/api/malware-detection/v1/graphql
#rules_location=http://127.0.0.1:3000/api/malware-detection/v1/signatures.yar
rules_location=%s

# A GraphQL endpoint for sending the results of a scan, eg:
#results_location=http://127.0.0.1:3000/api/malware-detection/v1/graphql
results_location=%s

# Limit the number of string matches uploaded per rule, esp if there are a lot of matches for a file/PID
#string_match_limit=10

# Comma separated list of rules to exclude from the scan, eg:
#exclude_rules=SpammyRule, Irrelevant, just_because
#exclude_rules=

# URL for your proxy
#proxy_url=


[yara]
# Specific location of the yara binary file.  Autodetected if not specified.  Example: /usr/local/bin/yara
#location=

# Abort a particular scan if it takes longer than scan_timeout seconds
#scan_timeout=3600

# Nice value to run yara as
#nice=19

# Number of CPU threads yara will use
#cpu_thread_limit=2


[auth]
# Subscription-manager certificate and key to use for authenticating to console.redhat.com
cert=/etc/pki/consumer/cert.pem
key=/etc/pki/consumer/key.pem

# Authentication options if using an endpoint for rules & results that requires a Keycloak JWT token to access
#keycloak_url=
#username=
#password=
#client_id=
"""


def create_new_conf_file(new_conf_file, rules_location='', results_url=''):
    from six.moves import input

    conf_file_template = CONF_FILE_TEMPLATE % (rules_location, results_url)
    if os.path.isfile(new_conf_file):
        ans = input("Configuration file '%s' already exists.  Overwrite? (y/N) " % new_conf_file)
        if ans.lower() not in ('y', 'yes'):
            logger.info("Config file not overwritten.")
            sys.exit(1)

    try:
        with open(new_conf_file, mode='w') as cf:
            cf.write(conf_file_template)
    except Exception as e:
        logger.error("Error writing config file: %s", e)
        sys.exit(1)

    logger.info("Created new configuration file in %s", new_conf_file)
    sys.exit(0)


def load_jwt_token():
    """
    Load the JWT token from the user's jwt_token_cache, if the file exists
    and if the token hasn't expired
    """
    jwt_token_cache = get_jwt_token_cache()
    try:
        token = json.loads(open(jwt_token_cache).read())
        decoded_token = jwt.decode(token['cs_jwt'], options={'verify_signature': False}, verify=False)
        token_expiry = datetime.utcfromtimestamp(decoded_token['exp'])
        if token_expiry <= datetime.utcnow():
            logger.debug("Locally stored JWT token has expired, requesting a new one")
            return None
        logger.debug("Loaded JWT token from %s" % jwt_token_cache)
        return token
    except Exception as e:
        logger.debug("Unable to load JWT token from %s: %s" % (jwt_token_cache, str(e)))
        return None


def save_jwt_token(jwt_token):
    """
    Save the JWT token to the user's jwt_token_cache
    """
    jwt_token_cache = get_jwt_token_cache()
    try:
        logger.debug("Saving JWT token to %s" % jwt_token_cache)
        with open(jwt_token_cache, 'w', 0o600) as cache:
            cache.write(json.dumps(jwt_token))
    except Exception as e:
        logger.debug("Unable to write JWT token to %s: %s" % (jwt_token_cache, str(e)))


def get_jwt_token_cache():
    """
    Get the filename where the JWT token is stored
    """
    from pwd import getpwuid
    user_home_dir = os.getenv('HOME') if os.getenv('HOME') else getpwuid(os.getuid()).pw_dir
    if not user_home_dir or user_home_dir == '/':
        user_home_dir = '/tmp'
    user_conf_dir = os.path.join(user_home_dir, '.config/malware-detection-client')
    if not os.path.exists(user_conf_dir):
        os.makedirs(user_conf_dir, 0o700)
    return os.path.join(user_conf_dir, 'jwt_token_cache')


def run_cmd(cmd):
    try:
        stdout, stderr = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()
        return stdout.decode('utf-8').strip()
    except subprocess.CalledProcessError as cpe:
        logger.debug("Problem running %s: %s", cmd, str(cpe))
        return ""


def string_to_bool(s):
    return s.lower() in ("yes", "true", "t", "1")


def get_insights_id():
    """
    Get the machine_id from insights-client
    If the machine_id doesn't exist, return a dummy value for the time being
    """
    insights_id_file = '/etc/insights-client/machine-id'
    try:
        with open(insights_id_file) as f:
            return f.read()
    except Exception as e:
        logger.error('Error reading %s to obtain the insightsId: %s.  Is the machine registered with Insights?',
                     insights_id_file, str(e))
        return '11111111-1111-1111-1111-111111111111'  # dummy value
        # sys.exit(1)


def get_identity_header(account_number=None):
    if account_number:
        identity = base64.b64encode(json.dumps({'identity': {'account_number': account_number,
                                                             'system': {'cn': gethostname()}}
                                                }).encode('utf-8'))
        return {'x-rh-identity': identity}
    else:
        return {}


def create_session():
    # Create the requests session so it has a default timeout of 2 minutes
    # and retries failed connections 5 times

    default_timeout = 120  # seconds

    class TimeoutHTTPAdapter(requests.adapters.HTTPAdapter):
        def __init__(self, *args, **kwargs):
            self.timeout = default_timeout
            if "timeout" in kwargs:
                self.timeout = kwargs["timeout"]
                del kwargs["timeout"]
            super(TimeoutHTTPAdapter, self).__init__(*args, **kwargs)

        def send(self, request, **kwargs):
            timeout = kwargs.get("timeout")
            if timeout is None:
                kwargs["timeout"] = self.timeout
            return super(TimeoutHTTPAdapter, self).send(request, **kwargs)

    session = requests.Session()
    adapter = TimeoutHTTPAdapter(max_retries=Retry(total=5, backoff_factor=1))
    session.mount('https://', adapter)
    session.mount('http://', adapter)
    return session
