# Testing MalwareDetectionClient
import os
import string
import random
import unittest
from client import MalwareDetectionClient


def get_random_string():
    # Used for making randomized test file names (so they don't accidentally clash with real files on the system)
    return ''.join(random.choice(string.ascii_lowercase) for _ in range(5))


class TestMalwareDetectionClient(unittest.TestCase):

    conf_file = "/tmp/test_malware_detection_client_%s.conf" % get_random_string()
    test_prefix = '.' if os.getcwd().endswith('tests') else 'tests'
    test_rule1 = "%s/test_rule1.yar" % test_prefix
    test_rule2 = "%s/test_rule2.yar" % test_prefix
    test_rules_compiled = "%s/test_rules_compiled.yar" % test_prefix
    test_client = "%s/test_client.py" % test_prefix
    location_params = {'rules_location': test_rules_compiled, 'results_url': 'http://127.0.0.1/'}

    @classmethod
    def setUpClass(cls):
        # Create a conf file to be used throughout the tests.  Includes the rule_location and results_url.
        if os.path.exists(cls.conf_file):
            os.remove(cls.conf_file)
        with cls.assertRaises(cls, SystemExit):
            MalwareDetectionClient(create_conf=True, conf_file=cls.conf_file,
                                   **cls.location_params)
        # Verify the location_params were written to the conf file
        with open(cls.conf_file) as cf:
            lines = cf.read().splitlines()
        cls.assertIn(cls, 'location=%s' % cls.test_rules_compiled, lines)
        cls.assertIn(cls, 'location=http://127.0.0.1/', lines)

    @classmethod
    def tearDownClass(cls):
        if os.path.exists(cls.conf_file):
            os.remove(cls.conf_file)

    def assert_defaults(self, mdc):
        self.assertTrue(mdc.yara_binary in ['/usr/local/bin/yara', '/usr/bin/yara', '/bin/yara'])
        self.assertEqual(mdc.rules_file, self.test_rules_compiled)
        self.assertEqual(mdc.compiled_rules_flag, '-C')
        self.assertEqual(mdc.do_filesystem_scan, True)
        self.assertEqual(mdc.do_process_scan, True)
        self.assertFalse(hasattr(mdc, 'scan_fsobjects'))
        self.assertFalse(hasattr(mdc, 'scan_pids'))
        self.assertEqual(mdc.results_url, 'http://127.0.0.1/')

    def test_default_options(self):
        # When writing a new/default conf file, then errors occur because the rule and result locations aren't populated
        try:
            conf_file = '/tmp/test_default_malware_detection_client_%s.conf' % get_random_string()
            if os.path.exists(conf_file):
                os.remove(conf_file)
            # Client exits after creating a conf, so catch that
            with self.assertRaises(SystemExit):
                MalwareDetectionClient(create_conf=True, conf_file=conf_file)

            # No rule location specified, so exit with error
            with self.assertRaises(SystemExit) as cm:
                with self.assertLogs() as log:
                    mdc = MalwareDetectionClient(conf_file=conf_file)
            self.assertIn("ERROR:malware_detection_client:No location specified from which to retrieve the rules, exiting",
                          log.output)
            self.assertEqual(cm.exception.code, 1)

            # Now we specify a rule_location but no results location, so exit with error about results location
            with self.assertRaises(SystemExit) as cm:
                with self.assertLogs() as log:
                    mdc = MalwareDetectionClient(conf_file=conf_file, rules_location=self.test_rules_compiled)
            self.assertIn("ERROR:malware_detection_client:No location specified to which to upload results, exiting",
                          log.output)
            self.assertEqual(cm.exception.code, 1)
        finally:
            if os.path.exists(conf_file):
                os.remove(conf_file)

        # With the conf file we created earlier, there is no error because we supplied a rules_location and results_url
        mdc = MalwareDetectionClient(conf_file=self.conf_file, debug=True)
        self.assert_defaults(mdc)

    def test_modified_options(self):
        # The self.conf_file has rules and results locations populated, so expect no errors
        mdc = MalwareDetectionClient(conf_file=self.conf_file)
        self.assertEqual(mdc.rules_file, self.test_rules_compiled)
        self.assertEqual(mdc.compiled_rules_flag, '-C')
        self.assertEqual(mdc.do_filesystem_scan, True)
        self.assertEqual(mdc.do_process_scan, True)
        self.assertFalse(hasattr(mdc, 'scan_fsobjects'))
        self.assertFalse(hasattr(mdc, 'scan_pids'))

        # Use a text rules file, expect the compiled_rules_flag is empty
        mdc = MalwareDetectionClient(conf_file=self.conf_file, rules_location=self.test_rule1)
        self.assertEqual(mdc.rules_file, self.test_rule1)
        self.assertEqual(mdc.compiled_rules_flag, '')

        # Test scanning just a PID, expect just the do_process_scan to be True
        mdc = MalwareDetectionClient(conf_file=self.conf_file, scan_entity='1')
        self.assertEqual(mdc.do_filesystem_scan, False)
        self.assertEqual(mdc.do_process_scan, True)
        self.assertFalse(hasattr(mdc, 'scan_fsobjects'))
        self.assertEqual(mdc.scan_pids, [1])

        # Test scanning just a file, expect just the do_filesystems_scan to be True
        mdc = MalwareDetectionClient(conf_file=self.conf_file, scan_entity=self.test_client)
        self.assertEqual(mdc.do_filesystem_scan, True)
        self.assertEqual(mdc.do_process_scan, False)
        self.assertEqual(mdc.scan_fsobjects, [self.test_client])
        self.assertFalse(hasattr(mdc, 'scan_pids'))

    def test_scanning_tests_files(self):
        # Test scanning the compiled rules file
        with self.assertLogs() as logs:
            mdc = MalwareDetectionClient(scan_entity=self.test_rules_compiled, **self.location_params)
            mdc.scan_filesystem()
        self.assertIn("INFO:malware_detection_client:Scan argument: file %s" % self.test_rules_compiled, logs.output)
        self.assertIn("INFO:malware_detection_client:Getting rules from %s" % self.test_rules_compiled, logs.output)
        self.assertIn("INFO:malware_detection_client:Scanning %s ..." % self.test_rules_compiled, logs.output)
        self.assertIn("INFO:malware_detection_client:Matched rule MalwareDetectionClientRule in file %s"
                      % self.test_rules_compiled, logs.output)
        self.assertIn("INFO:malware_detection_client:Matched rule MiscellaneousStringsRule in file %s"
                      % self.test_rules_compiled, logs.output)
        # Matched 2 rules
        self.assertEqual(mdc.matches, 2)
        # Matched rule strings 3 times
        string_matches = sum([len(mdc.host_scan[x]) for x in mdc.host_scan])
        self.assertEqual(string_matches, 3)
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        self.assertEqual(rule_match[0]['source'], self.test_rules_compiled)
        self.assertEqual(rule_match[0]['string_data'], ' MalwareDetectionClient')
        self.assertEqual(rule_match[0]['string_identifier'], '$text1')
        self.assertAlmostEqual(rule_match[0]['string_offset'], 500, delta=200)
        rule_match = mdc.host_scan['MiscellaneousStringsRule']
        self.assertEqual(rule_match[0]['source'], self.test_rules_compiled)
        self.assertEqual(rule_match[0]['string_data'], ' sent"')
        self.assertEqual(rule_match[0]['string_identifier'], '$string1')
        self.assertAlmostEqual(rule_match[0]['string_offset'], 500, delta=200)
        self.assertEqual(rule_match[1]['source'], self.test_rules_compiled)
        self.assertEqual(rule_match[1]['string_data'], ' ata_sff\\x00bioset\\x00bond0\\x00cifsd\\x00')
        self.assertEqual(rule_match[1]['string_identifier'], '$string2')
        self.assertAlmostEqual(rule_match[1]['string_offset'], 500, delta=200)
        self.assertFalse(mdc.scan_processes())

        # Test scanning this test_client.py file.  Expect to find 10 matches (with string_match_limit set to 10)
        mdc = MalwareDetectionClient(scan_entity=self.test_client, **self.location_params)
        self.assertEqual(mdc.string_match_limit, 10)
        mdc.scan_filesystem()
        self.assertEqual(mdc.matches, 2)  # Matches the two rules
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        self.assertEqual(len(rule_match), 10)  # Because string_match_limit = 10
        self.assertEqual(rule_match[0]['source'], self.test_client)
        self.assertEqual(rule_match[0]['string_data'], ' MalwareDetectionClient')
        self.assertEqual(rule_match[0]['string_identifier'], '$text1')
        # First match is near the start of the file
        self.assertAlmostEqual(rule_match[0]['string_offset'], 50, delta=50)

        # Increase string_match_limit and scan again.  Expect to find more than 10 matches
        mdc.string_match_limit = 100
        mdc.scan_filesystem()
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        self.assertGreater(len(rule_match), 10)

    def test_scanning_tests_directory(self):
        # Test scanning all the files in the tests directory
        with self.assertLogs() as logs:
            mdc = MalwareDetectionClient(scan_entity=self.test_prefix, **self.location_params)
            mdc.scan_filesystem()
        self.assertIn("INFO:malware_detection_client:Scan argument: directory %s" % self.test_prefix, logs.output)
        self.assertIn("INFO:malware_detection_client:Getting rules from %s" % self.test_rules_compiled, logs.output)
        self.assertIn("INFO:malware_detection_client:Scanning %s ..." % self.test_prefix, logs.output)
        self.assertIn("INFO:malware_detection_client:Matched rule MalwareDetectionClientRule in file %s"
                      % self.test_rule1, logs.output)
        self.assertIn("INFO:malware_detection_client:Matched rule MiscellaneousStringsRule in file %s"
                      % self.test_rule2, logs.output)
        # By default, skip the rules file (self.test_rules_compiled) because it will cause matches
        self.assertNotIn(self.test_rules_compiled, logs.output)

        # Expect 4 matches ...
        # - MalwareDetectionClientRule to match files test_rule1 and test_client
        # - MiscellaneousStringsRule to match files test_rule2 and test_client
        self.assertEqual(mdc.matches, 4)
        # Expect MalwareDetectionClientRule to match 1 string in test_rule1 and > 10 strings in test_client
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        rule_match_sources = [rm['source'] for rm in rule_match]
        self.assertIn(self.test_rule1, rule_match_sources)
        self.assertEqual(len(list(filter(lambda x: x == self.test_rule1, rule_match_sources))), 1)
        self.assertIn(self.test_client, rule_match_sources)
        self.assertEqual(len(list(filter(lambda x: x == self.test_client, rule_match_sources))), 10)
        # Expect MiscellaneousStringsRule to match 2 strings in test_rule2 and >= 1 strings in test_client
        rule_match = mdc.host_scan['MiscellaneousStringsRule']
        rule_match_sources = [rm['source'] for rm in rule_match]
        self.assertIn(self.test_rule2, rule_match_sources)
        self.assertEqual(len(list(filter(lambda x: x == self.test_rule2, rule_match_sources))), 2)
        self.assertIn(self.test_client, rule_match_sources)
        self.assertGreaterEqual(len(list(filter(lambda x: x == self.test_client, rule_match_sources))), 1)

    def test_scanning_unittest_process(self):
        # Scan the process that is running the tests
        test_pid = str(os.getpid())
        with self.assertLogs() as logs:
            mdc = MalwareDetectionClient(scan_entity=test_pid, **self.location_params)
        self.assertIn("INFO:malware_detection_client:Scan argument: pid %s" % test_pid, logs.output)

        self.assertFalse(mdc.scan_filesystem())
        with self.assertLogs() as logs:
            mdc.scan_processes()
        self.assertIn("INFO:malware_detection_client:Scanning pid %s ..." % test_pid, logs.output)
        self.assertIn("INFO:malware_detection_client:Matched rule MalwareDetectionClientRule in PID %s" % test_pid,
                      logs.output)
        # Matches both rules in the PID
        self.assertEqual(mdc.matches, 2)
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        self.assertEqual(len(rule_match), 10)
        self.assertEqual(rule_match[0]['source'], test_pid)
        self.assertEqual(rule_match[0]['string_data'], ' MalwareDetectionClient')
        self.assertEqual(rule_match[0]['string_identifier'], '$text1')
        self.assertGreater(rule_match[0]['string_offset'], 0)


CONTRIVED_SCAN_OUTPUT = """
error scanning this line, it will be skipped
this line also contains error scanning so it will be skipped too
0x1:$string1: skip me coz the rule line had an error
0x11:$string2: skip me too
0x111:$string3: skip me three
this line doesn't contain e-r-r-o-r s-c-a-n-n-i-n-g so will be considered a scan match, even though it shouldn't
0x123:$match: matches 'this' rule
BadFormat
0x1:$skipme: the previous line will fail because it doesn't follow the 'rule matching_entity' format
rule:matching_entity
0x1:$alsoskipme: the previous line also fails because it has a ":" instead of a " " between rule & matching_entity
rule matching_entity
0x0:$match0: string match in the file "matching_entity"
0x1:$match1: another string match in matching_entity
0x2:$match2: string with different types of quotes 'here' and "here"
rule another matching_entity
0x3:$match3: string match containing error scanning but it's ok because its not in a rule line
rule matching_entity_3, but without any string matches - yes that's ok
more error scanning this line
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859error scanning /dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app2.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule 12345
0x0:$s0: #!/bin/sh
"""

MATCHES_DIRECTORY_SCAN_OUTPUT = """
error scanning matches/kcore: error: 4
XFTI_brootkit matches/brootkit_match
0x0:$hdr: #!/
0x1a:$path: BR_ROOTKIT_PATH
0x11:$br_brootkit: brootkit
0x2a:$br_brootkit: brootkit
XFTI_FinSpy matches/finspy_match
0x18:$fin_unpacked1: fin_conn_
0x24:$fin_unpacked2: fin_relay_
0x31:$fin_unpacked3: fin_util_
0x3d:$fin_unpacked4: fin_read_
0x49:$fin_unpacked5: fin_conf
0xf:$fin_unpacked6: FinSpy
0x54:$fin_unpacked6: finspy
XFTI_FritzFrog matches/fritzfrog_match
0x0:$ELF_hdr: 7F 45 4C 46
0xee:$golang: /usr/lib/golang/src/
0x7a:$cmd_getbin: main.getbin
0x8a:$cmd_getstats: main.getstats
0xa2:$cmd_getpeerstats: main.getpeerstats
0xbe:$cmd_getblobstats: main.getblobstats
0xda:$cmd_getvotestats: main.getvotestats
XFTI_Mirai matches/mirai_match
0x1:$magic: 45 4C 46
0x1a:$string_2: GET /cgi-bin/nobody/
0x30:$string_3: POST /UD/?5 HTTP/1.1
0x46:$string_4: str=Lw==&username=admin
0x5f:$string_5: 20Account.User1.Password%3E
"""

ERROR_SCAN_OUTPUT = """
error scanning /var/lib/snapd//snap/core/10859/dev/core: could not open file
error scanning /var/lib/snapd//snap/core/10859/dev/fd/3/cookie/snap.core: could not open file
error scanning /var/lib/snapd//cookie/snap.gnome-3-28-1804: could not open file
error scanning /var/lib/snapd//device/private-keys-v1/_53ir43FCxbgdSyj8NriGt9gfonABhzHHhsGnGhvjqpK_hwdIcP0ScJpKppzEhps: could not open file
"""

ERROR4_SCAN_OUTPUT = """
error scanning /var/lib/snapd/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
"""

RANDOM_OUTPUT = """
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
Dictum at tempor commodo ullamcorper a lacus vestibulum sed. Non odio euismod lacinia at quis risus sed.
"""


class TestParseScanOutput(unittest.TestCase):

    conf_file = "/tmp/test_malware_detection_client_%s.conf" % get_random_string()
    test_prefix = '.' if os.getcwd().endswith('tests') else 'tests'
    test_rules_compiled = "%s/test_rules_compiled.yar" % test_prefix
    location_params = {'rules_location': test_rules_compiled, 'results_url': 'http://127.0.0.1/'}

    @classmethod
    def setUpClass(cls):
        # Create MalwareDetectionClient instance to be used throughout the tests
        if os.path.exists(cls.conf_file):
            os.remove(cls.conf_file)
        with cls.assertRaises(cls, SystemExit):
            MalwareDetectionClient(create_conf=True, conf_file=cls.conf_file, **cls.location_params)

    @classmethod
    def tearDownClass(cls):
        if os.path.exists(cls.conf_file):
            os.remove(cls.conf_file)

    def test_contrived_scan_output(self):
        mdc = MalwareDetectionClient(conf_file=self.conf_file)
        mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)
        # 1 match for rule 'this', 3 matches for rule 'rule', 2 matches for rule 'another_matching_rule'
        self.assertEqual(mdc.matches, 6)

        # 1 matching string for 'this'
        rule_match = mdc.host_scan['this']
        self.assertEqual(len(rule_match), 1)
        self.assertIn('e-r-r-o-r s-c-a-n-n-i-n-g', rule_match[0]['source'])
        self.assertEqual(rule_match[0]['string_data'], " matches 'this' rule")
        self.assertEqual(rule_match[0]['string_identifier'], '$match')
        self.assertEqual(rule_match[0]['string_offset'], 291)

        # 5 matching strings for 'rule'
        rule_match = mdc.host_scan['rule']
        self.assertEqual(len(rule_match), 5)
        self.assertEqual(rule_match[0]['source'], 'matching_entity')
        self.assertEqual(rule_match[0]['string_data'], ' string match in the file "matching_entity"')
        self.assertEqual(rule_match[0]['string_identifier'], '$match0')
        self.assertEqual(rule_match[0]['string_offset'], 0)
        self.assertEqual(rule_match[1]['source'], 'matching_entity')
        self.assertEqual(rule_match[1]['string_data'], " another string match in matching_entity")
        self.assertEqual(rule_match[1]['string_identifier'], '$match1')
        self.assertEqual(rule_match[1]['string_offset'], 1)
        self.assertEqual(rule_match[2]['source'], 'matching_entity')
        self.assertEqual(rule_match[2]['string_data'], ' string with different types of quotes \'here\' and "here"')
        self.assertEqual(rule_match[2]['string_identifier'], '$match2')
        self.assertEqual(rule_match[2]['string_offset'], 2)
        self.assertEqual(rule_match[3]['source'], 'another matching_entity')
        self.assertEqual(rule_match[3]['string_data'], " string match containing error scanning but it's ok because its not in a rule line")
        self.assertEqual(rule_match[3]['string_identifier'], '$match3')
        self.assertEqual(rule_match[3]['string_offset'], 3)
        self.assertTrue(rule_match[4]['source'].startswith('matching_entity_3'))
        self.assertEqual(rule_match[4]['string_data'], '')
        self.assertEqual(rule_match[4]['string_identifier'], '')
        self.assertEqual(rule_match[4]['string_offset'], -1)

        # 3 matching strings for 'rule_with_long_filename_match'
        rule_match = mdc.host_scan['another_matching_rule']
        self.assertEqual(len(rule_match), 4)
        self.assertTrue(rule_match[2]['source'].endswith('snap/signal-desktop/350/opt/Signal/resources/app.asar'))
        self.assertEqual(rule_match[2]['string_data'], ' #!/bin/sh')
        self.assertEqual(rule_match[2]['string_identifier'], '$s0')
        self.assertEqual(rule_match[2]['string_offset'], 60783814)
        self.assertEqual(rule_match[3]['source'], '12345')
        self.assertEqual(rule_match[3]['string_data'], ' #!/bin/sh')
        self.assertEqual(rule_match[3]['string_identifier'], '$s0')
        self.assertEqual(rule_match[3]['string_offset'], 0)

    def test_matches_scan_output(self):
        mdc = MalwareDetectionClient(conf_file=self.conf_file)
        with self.assertLogs() as logs:
            mdc.parse_scan_output(MATCHES_DIRECTORY_SCAN_OUTPUT)
        self.assertEqual(mdc.matches, 4)
        self.assertNotIn('DEBUG:malware_detection_client:error scanning matches/kcore: error: 4', logs.output)
        self.assertIn('INFO:malware_detection_client:Matched rule XFTI_brootkit in file matches/brootkit_match',
                      logs.output)
        self.assertIn('INFO:malware_detection_client:Matched rule XFTI_FinSpy in file matches/finspy_match',
                      logs.output)
        self.assertIn('INFO:malware_detection_client:Matched rule XFTI_FritzFrog in file matches/fritzfrog_match',
                      logs.output)
        self.assertIn('INFO:malware_detection_client:Matched rule XFTI_Mirai in file matches/mirai_match',
                      logs.output)
        self.assertEqual(len(mdc.host_scan['XFTI_brootkit']), 4)
        self.assertEqual(len(mdc.host_scan['XFTI_FinSpy']), 7)
        self.assertEqual(len(mdc.host_scan['XFTI_FritzFrog']), 7)
        self.assertEqual(len(mdc.host_scan['XFTI_Mirai']), 5)

        # With debug enabled the 'error scanning ... error: 4' will be logged
        mdc = MalwareDetectionClient(conf_file=self.conf_file, debug=True)
        with self.assertLogs() as logs:
            mdc.parse_scan_output(MATCHES_DIRECTORY_SCAN_OUTPUT)
        self.assertIn('DEBUG:malware_detection_client:error scanning matches/kcore: error: 4', logs.output)

    def test_error_scan_output(self):
        mdc = MalwareDetectionClient(conf_file=self.conf_file)
        with self.assertLogs() as logs:
            mdc.parse_scan_output(ERROR_SCAN_OUTPUT)
        self.assertEqual(mdc.matches, 0)
        self.assertEqual(mdc.host_scan, {})
        self.assertIn('INFO:malware_detection_client:error scanning /var/lib/snapd//snap/core/10859/dev/core: could not open file',
                      logs.output)

    def test_error4_scan_output(self):
        mdc = MalwareDetectionClient(conf_file=self.conf_file, debug=True)
        with self.assertLogs() as logs:
            mdc.parse_scan_output(ERROR4_SCAN_OUTPUT)
        self.assertEqual(mdc.matches, 0)
        self.assertEqual(mdc.host_scan, {})
        self.assertIn('DEBUG:malware_detection_client:error scanning /var/lib/snapd/snap/core/10859/dev/core: error: 4',
                      logs.output)

    def test_random_output(self):
        mdc = MalwareDetectionClient(conf_file=self.conf_file)
        mdc.parse_scan_output(RANDOM_OUTPUT)
        self.assertEqual(mdc.matches, 2)
        rule_match = mdc.host_scan['Lorem']
        self.assertTrue(rule_match[0]['source'].startswith('ipsum dolor'))
        self.assertEqual(rule_match[0]['string_data'], '')
        self.assertEqual(rule_match[0]['string_identifier'], '')
        self.assertEqual(rule_match[0]['string_offset'], -1)
        rule_match = mdc.host_scan['Dictum']
        self.assertTrue(rule_match[0]['source'].startswith('at tempor'))
        self.assertEqual(rule_match[0]['string_data'], '')
        self.assertEqual(rule_match[0]['string_identifier'], '')
        self.assertEqual(rule_match[0]['string_offset'], -1)


if __name__ == '__main__':
    unittest.main()
