import os
import json
import string
import random
import unittest2
import responses
try:
    from urllib.parse import parse_qsl
except ImportError:
    from urlparse import parse_qsl
from malware_detection_client import MalwareDetectionClient


def get_random_string():
    # Used for making randomized test file names (so they don't accidentally clash with real files on the system)
    return ''.join(random.choice(string.ascii_lowercase) for _ in range(5))


def remove_conf_file():
    if os.path.exists(CONF_FILE):
        os.remove(CONF_FILE)


CONF_FILE = "/tmp/test_malware_detection_client_%s.conf" % get_random_string()
TEST_PREFIX = '.' if os.getcwd().endswith('tests') else 'tests'
TEST_RULE1 = "%s/test_rule1.yar" % TEST_PREFIX
TEST_RULE2 = "%s/test_rule2.yar" % TEST_PREFIX
TEST_RULES_COMPILED = "%s/test_rules_compiled.yar" % TEST_PREFIX
TEST_CLIENT = "%s/test_malware_detection_client.py" % TEST_PREFIX
TEST_RESULTS_URL = 'http://127.0.0.1/graphql'
TEST_KEYCLOAK_URL = 'http://127.0.0.1/token'
LOCATION_PARAMS = {'rules_location': TEST_RULES_COMPILED, 'results_url': TEST_RESULTS_URL}


class TestMalwareDetectionClient(unittest2.TestCase):

    def setUp(self):
        # Create a conf file to be used throughout the tests.  Includes the rule_location and results_url.
        remove_conf_file()
        with self.assertRaises(SystemExit):
            MalwareDetectionClient(create_conf=True, conf_file=CONF_FILE, **LOCATION_PARAMS)

    def tearDown(self):
        remove_conf_file()

    def assert_defaults(self, mdc):
        self.assertTrue(mdc.yara_binary in ['/usr/local/bin/yara', '/usr/bin/yara', '/bin/yara'])
        self.assertEqual(mdc.rules_file, TEST_RULES_COMPILED)
        self.assertEqual(mdc.compiled_rules_flag, '-C')
        self.assertEqual(mdc.do_filesystem_scan, True)
        self.assertEqual(mdc.do_process_scan, True)
        self.assertFalse(hasattr(mdc, 'scan_fsobjects'))
        self.assertFalse(hasattr(mdc, 'scan_pids'))
        self.assertEqual(mdc.results_url, TEST_RESULTS_URL)

    def test_default_options(self):
        # When writing a new/default conf file, then errors occur because the rule and result locations aren't populated
        try:
            default_conf_file = '/tmp/test_default_malware_detection_client_%s.conf' % get_random_string()
            if os.path.exists(default_conf_file):
                os.remove(default_conf_file)
            # Client exits after creating a conf, so catch that
            with self.assertRaises(SystemExit):
                MalwareDetectionClient(create_conf=True, conf_file=default_conf_file)

            # No rule location specified, so exit with error
            with self.assertRaises(SystemExit) as exc, self.assertLogs() as log:
                mdc = MalwareDetectionClient(conf_file=default_conf_file)
            self.assertIn("ERROR:malware_detection_client:No location specified from which to retrieve the rules, exiting",
                          log.output)
            self.assertEqual(exc.exception.code, 1)

            # Now we specify a rule_location but no results location, so exit with error about results location
            with self.assertRaises(SystemExit) as exc, self.assertLogs() as log:
                mdc = MalwareDetectionClient(conf_file=default_conf_file, rules_location=TEST_RULES_COMPILED)
            self.assertIn("ERROR:malware_detection_client:No location specified to which to upload results, exiting",
                          log.output)
            self.assertEqual(exc.exception.code, 1)
        finally:
            if os.path.exists(default_conf_file):
                os.remove(default_conf_file)

        # With the conf file we created earlier, there is no error because we supplied a rules_location and results_url
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, debug=True)
        self.assert_defaults(mdc)

    def test_modified_options(self):
        # The self.conf_file has rules and results locations populated, so expect no errors
        mdc = MalwareDetectionClient(conf_file=CONF_FILE)
        self.assertEqual(mdc.rules_file, TEST_RULES_COMPILED)
        self.assertEqual(mdc.compiled_rules_flag, '-C')
        self.assertEqual(mdc.do_filesystem_scan, True)
        self.assertEqual(mdc.do_process_scan, True)
        self.assertFalse(hasattr(mdc, 'scan_fsobjects'))
        self.assertFalse(hasattr(mdc, 'scan_pids'))

        # Use a text rules file, expect the compiled_rules_flag is empty
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, rules_location=TEST_RULE1)
        self.assertEqual(mdc.rules_file, TEST_RULE1)
        self.assertEqual(mdc.compiled_rules_flag, '')

        # Test scanning just a PID, expect just the do_process_scan to be True
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity='1')
        self.assertEqual(mdc.do_filesystem_scan, False)
        self.assertEqual(mdc.do_process_scan, True)
        self.assertFalse(hasattr(mdc, 'scan_fsobjects'))
        self.assertEqual(mdc.scan_pids, [1])

        # Test scanning just a file, expect just the do_filesystems_scan to be True
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_CLIENT)
        self.assertEqual(mdc.do_filesystem_scan, True)
        self.assertEqual(mdc.do_process_scan, False)
        self.assertEqual(mdc.scan_fsobjects, [TEST_CLIENT])
        self.assertFalse(hasattr(mdc, 'scan_pids'))

    def test_scanning_tests_files(self):
        # Test scanning the compiled rules file
        with self.assertLogs() as logs:
            mdc = MalwareDetectionClient(scan_entity=TEST_RULES_COMPILED, **LOCATION_PARAMS)
            mdc.scan_filesystem()
        self.assertIn("INFO:malware_detection_client:Scan argument: file %s" % TEST_RULES_COMPILED, logs.output)
        self.assertIn("INFO:malware_detection_client:Getting rules from %s" % TEST_RULES_COMPILED, logs.output)
        self.assertIn("INFO:malware_detection_client:Scanning %s ..." % TEST_RULES_COMPILED, logs.output)
        self.assertIn("INFO:malware_detection_client:Matched rule MalwareDetectionClientRule in file %s"
                      % TEST_RULES_COMPILED, logs.output)
        self.assertIn("INFO:malware_detection_client:Matched rule MiscellaneousStringsRule in file %s"
                      % TEST_RULES_COMPILED, logs.output)
        # Matched 2 rules
        self.assertEqual(mdc.matches, 2)
        # Matched rule strings 3 times
        string_matches = sum([len(mdc.host_scan[x]) for x in mdc.host_scan])
        self.assertEqual(string_matches, 3)
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        self.assertEqual(rule_match[0]['source'], TEST_RULES_COMPILED)
        self.assertEqual(rule_match[0]['string_data'], ' MalwareDetectionClient')
        self.assertEqual(rule_match[0]['string_identifier'], '$text1')
        self.assertAlmostEqual(rule_match[0]['string_offset'], 500, delta=200)
        rule_match = mdc.host_scan['MiscellaneousStringsRule']
        self.assertEqual(rule_match[0]['source'], TEST_RULES_COMPILED)
        self.assertEqual(rule_match[0]['string_data'], ' sent"')
        self.assertEqual(rule_match[0]['string_identifier'], '$string1')
        self.assertAlmostEqual(rule_match[0]['string_offset'], 500, delta=200)
        self.assertEqual(rule_match[1]['source'], TEST_RULES_COMPILED)
        self.assertEqual(rule_match[1]['string_data'], ' ata_sff\\x00bioset\\x00bond0\\x00cifsd\\x00')
        self.assertEqual(rule_match[1]['string_identifier'], '$string2')
        self.assertAlmostEqual(rule_match[1]['string_offset'], 500, delta=200)
        self.assertFalse(mdc.scan_processes())

        # Test scanning this test_malware_detection_client.py file.  Expect to find 10 matches (with string_match_limit set to 10)
        mdc = MalwareDetectionClient(scan_entity=TEST_CLIENT, **LOCATION_PARAMS)
        self.assertEqual(mdc.string_match_limit, 10)
        mdc.scan_filesystem()
        self.assertEqual(mdc.matches, 2)  # Matches the two rules
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        self.assertEqual(len(rule_match), 10)  # Because string_match_limit = 10
        self.assertEqual(rule_match[0]['source'], TEST_CLIENT)
        self.assertEqual(rule_match[0]['string_data'], ' MalwareDetectionClient')
        self.assertEqual(rule_match[0]['string_identifier'], '$text1')
        # First match is near the start of the file
        self.assertAlmostEqual(rule_match[0]['string_offset'], 200, delta=200)

        # Increase string_match_limit and scan again.  Expect to find more than 10 matches
        mdc.string_match_limit = 100
        mdc.scan_filesystem()
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        self.assertGreater(len(rule_match), 10)

    def test_scanning_tests_directory(self):
        # Test scanning all the files in the tests directory
        with self.assertLogs() as logs:
            mdc = MalwareDetectionClient(scan_entity=TEST_PREFIX, **LOCATION_PARAMS)
            mdc.scan_filesystem()
        self.assertIn("INFO:malware_detection_client:Scan argument: directory %s" % TEST_PREFIX, logs.output)
        self.assertIn("INFO:malware_detection_client:Getting rules from %s" % TEST_RULES_COMPILED, logs.output)
        self.assertIn("INFO:malware_detection_client:Scanning %s ..." % TEST_PREFIX, logs.output)
        self.assertIn("INFO:malware_detection_client:Matched rule MalwareDetectionClientRule in file %s"
                      % TEST_RULE1, logs.output)
        self.assertIn("INFO:malware_detection_client:Matched rule MiscellaneousStringsRule in file %s"
                      % TEST_RULE2, logs.output)
        # By default, skip the rules file (TEST_RULES_COMPILED) because it will cause matches
        self.assertNotIn(TEST_RULES_COMPILED, logs.output)

        # Expect 4 matches ...
        # - MalwareDetectionClientRule to match files test_rule1 and test_malware_detection_client
        # - MiscellaneousStringsRule to match files test_rule2 and test_malware_detection_client
        self.assertEqual(mdc.matches, 4)
        # Expect MalwareDetectionClientRule to match 1 string in test_rule1 and > 10 strings in test_malware_detection_client
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        rule_match_sources = [rm['source'] for rm in rule_match]
        self.assertIn(TEST_RULE1, rule_match_sources)
        self.assertEqual(len(list(filter(lambda x: x == TEST_RULE1, rule_match_sources))), 1)
        self.assertIn(TEST_CLIENT, rule_match_sources)
        self.assertEqual(len(list(filter(lambda x: x == TEST_CLIENT, rule_match_sources))), 10)
        # Expect MiscellaneousStringsRule to match 2 strings in test_rule2 and >= 1 strings in test_malware_detection_client
        rule_match = mdc.host_scan['MiscellaneousStringsRule']
        rule_match_sources = [rm['source'] for rm in rule_match]
        self.assertIn(TEST_RULE2, rule_match_sources)
        self.assertEqual(len(list(filter(lambda x: x == TEST_RULE2, rule_match_sources))), 2)
        self.assertIn(TEST_CLIENT, rule_match_sources)
        self.assertGreaterEqual(len(list(filter(lambda x: x == TEST_CLIENT, rule_match_sources))), 1)

    def test_scanning_unittest_process(self):
        # Scan the process that is running the tests
        test_pid = str(os.getpid())
        with self.assertLogs() as logs:
            mdc = MalwareDetectionClient(scan_entity=test_pid, **LOCATION_PARAMS)
        self.assertIn("INFO:malware_detection_client:Scan argument: pid %s" % test_pid, logs.output)

        self.assertFalse(mdc.scan_filesystem())
        with self.assertLogs() as logs:
            mdc.scan_processes()
        self.assertIn("INFO:malware_detection_client:Scanning pid %s ..." % test_pid, logs.output)
        self.assertIn("INFO:malware_detection_client:Matched rule MalwareDetectionClientRule in PID %s" % test_pid,
                      logs.output)
        # Matches both rules in the PID
        self.assertEqual(mdc.matches, 2)
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        self.assertEqual(len(rule_match), 10)
        self.assertEqual(rule_match[0]['source'], test_pid)
        self.assertEqual(rule_match[0]['string_data'], ' MalwareDetectionClient')
        self.assertEqual(rule_match[0]['string_identifier'], '$text1')
        self.assertGreater(rule_match[0]['string_offset'], 0)


CONTRIVED_SCAN_OUTPUT = """
error scanning this line, it will be skipped
this line also contains error scanning so it will be skipped too
0x1:$string1: skip me coz the rule line had an error
0x11:$string2: skip me too
0x111:$string3: skip me three
this line doesn't contain e-r-r-o-r s-c-a-n-n-i-n-g so will be considered a scan match, even though it shouldn't
0x123:$match: matches 'this' rule
BadFormat
0x1:$skipme: the previous line will fail because it doesn't follow the 'rule matching_entity' format
rule:matching_entity
0x1:$alsoskipme: the previous line also fails because it has a ":" instead of a " " between rule & matching_entity
rule matching_entity
0x0:$match0: string match in the file "matching_entity"
0x1:$match1: another string match in matching_entity
0x2:$match2: string with different types of quotes 'here' and "here"
rule another matching_entity
0x3:$match3: string match containing error scanning but it's ok because its not in a rule line
rule matching_entity_3, but without any string matches - yes that's ok
more error scanning this line
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859error scanning /dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/signal-desktop/350/opt/Signal/resources/app2.asar
0x212f197:$s0: #!/bin/sh
0x2130313:$s0: #!/bin/sh
0x39f7cc6:$s0: #!/bin/sh
another_matching_rule 12345
0x0:$s0: #!/bin/sh
"""

MATCHES_DIRECTORY_SCAN_OUTPUT = """
error scanning matches/kcore: error: 4
XFTI_brootkit matches/brootkit_match
0x0:$hdr: #!/
0x1a:$path: BR_ROOTKIT_PATH
0x11:$br_brootkit: brootkit
0x2a:$br_brootkit: brootkit
XFTI_FinSpy matches/finspy_match
0x18:$fin_unpacked1: fin_conn_
0x24:$fin_unpacked2: fin_relay_
0x31:$fin_unpacked3: fin_util_
0x3d:$fin_unpacked4: fin_read_
0x49:$fin_unpacked5: fin_conf
0xf:$fin_unpacked6: FinSpy
0x54:$fin_unpacked6: finspy
XFTI_FritzFrog matches/fritzfrog_match
0x0:$ELF_hdr: 7F 45 4C 46
0xee:$golang: /usr/lib/golang/src/
0x7a:$cmd_getbin: main.getbin
0x8a:$cmd_getstats: main.getstats
0xa2:$cmd_getpeerstats: main.getpeerstats
0xbe:$cmd_getblobstats: main.getblobstats
0xda:$cmd_getvotestats: main.getvotestats
XFTI_Mirai matches/mirai_match
0x1:$magic: 45 4C 46
0x1a:$string_2: GET /cgi-bin/nobody/
0x30:$string_3: POST /UD/?5 HTTP/1.1
0x46:$string_4: str=Lw==&username=admin
0x5f:$string_5: 20Account.User1.Password%3E
"""

ERROR_SCAN_OUTPUT = """
error scanning /var/lib/snapd//snap/core/10859/dev/core: could not open file
error scanning /var/lib/snapd//snap/core/10859/dev/fd/3/cookie/snap.core: could not open file
error scanning /var/lib/snapd//cookie/snap.gnome-3-28-1804: could not open file
error scanning /var/lib/snapd//device/private-keys-v1/_53ir43FCxbgdSyj8NriGt9gfonABhzHHhsGnGhvjqpK_hwdIcP0ScJpKppzEhps: could not open file
"""

ERROR4_SCAN_OUTPUT = """
error scanning /var/lib/snapd/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
error scanning /var/lib/snapd/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/fd/3/snap/core/10859/dev/core: error: 4
"""

RANDOM_OUTPUT = """
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
Dictum at tempor commodo ullamcorper a lacus vestibulum sed. Non odio euismod lacinia at quis risus sed.
"""


class TestParseScanOutput(unittest2.TestCase):

    def setUp(self):
        # Create a conf file to be used throughout the tests.  Includes the rule_location and results_url.
        remove_conf_file()
        with self.assertRaises(SystemExit):
            MalwareDetectionClient(create_conf=True, conf_file=CONF_FILE, **LOCATION_PARAMS)

    def tearDown(self):
        remove_conf_file()

    def test_contrived_scan_output(self):
        mdc = MalwareDetectionClient(conf_file=CONF_FILE)
        mdc.parse_scan_output(CONTRIVED_SCAN_OUTPUT)
        # 1 match for rule 'this', 3 matches for rule 'rule', 2 matches for rule 'another_matching_rule'
        self.assertEqual(mdc.matches, 6)

        # 1 matching string for 'this'
        rule_match = mdc.host_scan['this']
        self.assertEqual(len(rule_match), 1)
        self.assertIn('e-r-r-o-r s-c-a-n-n-i-n-g', rule_match[0]['source'])
        self.assertEqual(rule_match[0]['string_data'], " matches 'this' rule")
        self.assertEqual(rule_match[0]['string_identifier'], '$match')
        self.assertEqual(rule_match[0]['string_offset'], 291)

        # 5 matching strings for 'rule'
        rule_match = mdc.host_scan['rule']
        self.assertEqual(len(rule_match), 5)
        self.assertEqual(rule_match[0]['source'], 'matching_entity')
        self.assertEqual(rule_match[0]['string_data'], ' string match in the file "matching_entity"')
        self.assertEqual(rule_match[0]['string_identifier'], '$match0')
        self.assertEqual(rule_match[0]['string_offset'], 0)
        self.assertEqual(rule_match[1]['source'], 'matching_entity')
        self.assertEqual(rule_match[1]['string_data'], " another string match in matching_entity")
        self.assertEqual(rule_match[1]['string_identifier'], '$match1')
        self.assertEqual(rule_match[1]['string_offset'], 1)
        self.assertEqual(rule_match[2]['source'], 'matching_entity')
        self.assertEqual(rule_match[2]['string_data'], ' string with different types of quotes \'here\' and "here"')
        self.assertEqual(rule_match[2]['string_identifier'], '$match2')
        self.assertEqual(rule_match[2]['string_offset'], 2)
        self.assertEqual(rule_match[3]['source'], 'another matching_entity')
        self.assertEqual(rule_match[3]['string_data'], " string match containing error scanning but it's ok because its not in a rule line")
        self.assertEqual(rule_match[3]['string_identifier'], '$match3')
        self.assertEqual(rule_match[3]['string_offset'], 3)
        self.assertTrue(rule_match[4]['source'].startswith('matching_entity_3'))
        self.assertEqual(rule_match[4]['string_data'], '')
        self.assertEqual(rule_match[4]['string_identifier'], '')
        self.assertEqual(rule_match[4]['string_offset'], -1)

        # 3 matching strings for 'rule_with_long_filename_match'
        rule_match = mdc.host_scan['another_matching_rule']
        self.assertEqual(len(rule_match), 4)
        self.assertTrue(rule_match[2]['source'].endswith('snap/signal-desktop/350/opt/Signal/resources/app.asar'))
        self.assertEqual(rule_match[2]['string_data'], ' #!/bin/sh')
        self.assertEqual(rule_match[2]['string_identifier'], '$s0')
        self.assertEqual(rule_match[2]['string_offset'], 60783814)
        self.assertEqual(rule_match[3]['source'], '12345')
        self.assertEqual(rule_match[3]['string_data'], ' #!/bin/sh')
        self.assertEqual(rule_match[3]['string_identifier'], '$s0')
        self.assertEqual(rule_match[3]['string_offset'], 0)

    def test_matches_scan_output(self):
        mdc = MalwareDetectionClient(conf_file=CONF_FILE)
        with self.assertLogs() as logs:
            mdc.parse_scan_output(MATCHES_DIRECTORY_SCAN_OUTPUT)
        self.assertEqual(mdc.matches, 4)
        self.assertNotIn('DEBUG:malware_detection_client:error scanning matches/kcore: error: 4', logs.output)
        self.assertIn('INFO:malware_detection_client:Matched rule XFTI_brootkit in file matches/brootkit_match',
                      logs.output)
        self.assertIn('INFO:malware_detection_client:Matched rule XFTI_FinSpy in file matches/finspy_match',
                      logs.output)
        self.assertIn('INFO:malware_detection_client:Matched rule XFTI_FritzFrog in file matches/fritzfrog_match',
                      logs.output)
        self.assertIn('INFO:malware_detection_client:Matched rule XFTI_Mirai in file matches/mirai_match',
                      logs.output)
        self.assertEqual(len(mdc.host_scan['XFTI_brootkit']), 4)
        self.assertEqual(len(mdc.host_scan['XFTI_FinSpy']), 7)
        self.assertEqual(len(mdc.host_scan['XFTI_FritzFrog']), 7)
        self.assertEqual(len(mdc.host_scan['XFTI_Mirai']), 5)

        # Reduce the string_match_limit and some of the counts will change
        mdc = MalwareDetectionClient(conf_file=CONF_FILE)
        mdc.string_match_limit = 5
        mdc.parse_scan_output(MATCHES_DIRECTORY_SCAN_OUTPUT)
        self.assertEqual(len(mdc.host_scan['XFTI_brootkit']), 4)
        self.assertEqual(len(mdc.host_scan['XFTI_FinSpy']), 5)
        self.assertEqual(len(mdc.host_scan['XFTI_FritzFrog']), 5)
        self.assertEqual(len(mdc.host_scan['XFTI_Mirai']), 5)

        # Even with string_match_limit = 0, there will be 1 entry to record the source
        mdc = MalwareDetectionClient(conf_file=CONF_FILE)
        mdc.string_match_limit = 0
        mdc.parse_scan_output(MATCHES_DIRECTORY_SCAN_OUTPUT)
        self.assertEqual(len(mdc.host_scan['XFTI_brootkit']), 1)
        self.assertEqual(len(mdc.host_scan['XFTI_FinSpy']), 1)
        self.assertEqual(len(mdc.host_scan['XFTI_FritzFrog']), 1)
        self.assertEqual(len(mdc.host_scan['XFTI_Mirai']), 1)

        # With debug enabled the 'error scanning ... error: 4' will be logged
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, debug=True)
        with self.assertLogs() as logs:
            mdc.parse_scan_output(MATCHES_DIRECTORY_SCAN_OUTPUT)
        self.assertIn('DEBUG:malware_detection_client:error scanning matches/kcore: error: 4', logs.output)

    def test_error_scan_output(self):
        mdc = MalwareDetectionClient(conf_file=CONF_FILE)
        with self.assertLogs() as logs:
            mdc.parse_scan_output(ERROR_SCAN_OUTPUT)
        self.assertEqual(mdc.matches, 0)
        self.assertEqual(mdc.host_scan, {})
        self.assertIn('INFO:malware_detection_client:error scanning /var/lib/snapd//snap/core/10859/dev/core: could not open file',
                      logs.output)

    def test_error4_scan_output(self):
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, debug=True)
        with self.assertLogs() as logs:
            mdc.parse_scan_output(ERROR4_SCAN_OUTPUT)
        self.assertEqual(mdc.matches, 0)
        self.assertEqual(mdc.host_scan, {})
        self.assertIn('DEBUG:malware_detection_client:error scanning /var/lib/snapd/snap/core/10859/dev/core: error: 4',
                      logs.output)

    def test_random_output(self):
        mdc = MalwareDetectionClient(conf_file=CONF_FILE)
        mdc.parse_scan_output(RANDOM_OUTPUT)
        self.assertEqual(mdc.matches, 2)
        rule_match = mdc.host_scan['Lorem']
        self.assertTrue(rule_match[0]['source'].startswith('ipsum dolor'))
        self.assertEqual(rule_match[0]['string_data'], '')
        self.assertEqual(rule_match[0]['string_identifier'], '')
        self.assertEqual(rule_match[0]['string_offset'], -1)
        rule_match = mdc.host_scan['Dictum']
        self.assertTrue(rule_match[0]['source'].startswith('at tempor'))
        self.assertEqual(rule_match[0]['string_data'], '')
        self.assertEqual(rule_match[0]['string_identifier'], '')
        self.assertEqual(rule_match[0]['string_offset'], -1)


STRING_DATA = [' MalwareDetectionClient', ' sent"', ' ata_sff\\x00bioset\\x00bond0\\x00cifsd\\x00']
AUTH_DATA = {
    'keycloak_url': TEST_KEYCLOAK_URL,
    'client_id': 'client',
    'username': 'testing',
    'password': '123',
    'token': {'id_token': 'abc123', 'refresh_token': 'xyz789'}
}


def get_token(request):
    data = dict(parse_qsl(request.body))
    if any([auth_type for auth_type in ['username', 'password'] if data[auth_type] != AUTH_DATA[auth_type]]):
        return 401, {}, json.dumps({"error": "invalid_grant", "error_description": "Invalid user credentials"})
    elif data['client_id'] != AUTH_DATA['client_id']:
        return 400, {}, json.dumps({"error": "unauthorized_client", "error_description": "Invalid client credentials"})
    else:
        return 200, {}, json.dumps(AUTH_DATA['token'])


def do_upload(request):
    data = json.loads(request.body)
    for sd in STRING_DATA[1:]:
        assert sd not in data['query']
        assert json.dumps(sd) in data['query']
    return 200, {}, json.dumps({'recordHostScan': {'success': True}})


class TestNetworkFunctions(unittest2.TestCase):

    def setUp(self):
        # Create conf file to be used throughout the tests
        remove_conf_file()
        with self.assertRaises(SystemExit):
            MalwareDetectionClient(create_conf=True, conf_file=CONF_FILE, **LOCATION_PARAMS)
        responses.add_callback(responses.POST, TEST_KEYCLOAK_URL, callback=get_token)
        responses.add_callback(responses.POST, TEST_RESULTS_URL, callback=do_upload)

    def tearDown(self):
        remove_conf_file()

    @responses.activate
    def test_get_jwt_token(self):
        # No keycloak_url specified so no cookie created
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_PREFIX)
        mdc.get_jwt_token()
        self.assertEqual(mdc.cookie, {})

        # Try to get token with missing auth params - expect error message and exit
        with open(CONF_FILE, 'a') as cf:
            cf.write("keycloak_url = %s\n" % AUTH_DATA['keycloak_url'])
        with self.assertRaises(SystemExit) as exc, self.assertLogs() as logs:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_PREFIX)
            mdc.get_jwt_token()
        self.assertIn("ERROR:malware_detection_client:Missing authentication value for username, password, client_id",
                      logs.output)
        self.assertEqual(exc.exception.code, 1)

        # Try to get token with missing client_id auth param - still expect error message and exit
        with open(CONF_FILE, 'a') as cf:
            cf.write("username = %s\npassword = %s\n" % (AUTH_DATA['username'], AUTH_DATA['password']))
        with self.assertRaises(SystemExit) as exc, self.assertLogs() as logs:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_PREFIX)
            mdc.get_jwt_token()
        self.assertIn("ERROR:malware_detection_client:Missing authentication value for client_id", logs.output)
        self.assertEqual(exc.exception.code, 1)

        # All auth tokens supplied - expect response containing JWT cookie
        with open(CONF_FILE, 'a') as cf:
            cf.write("client_id = %s\n" % AUTH_DATA['client_id'])
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_PREFIX)
        mdc.get_jwt_token()
        self.assertEqual(mdc.cookie, {'cs_jwt': AUTH_DATA['token']['id_token'],
                                      'cs_jwt_refresh': AUTH_DATA['token']['refresh_token']})

    @responses.activate
    def test_get_jwt_token_invalid_creds(self):
        with open(CONF_FILE, 'a') as cf:
            cf.write("keycloak_url = %s\n" % AUTH_DATA['keycloak_url'])
            cf.write("username = %s\npassword = %s\n" % (AUTH_DATA['username'], 'incorrect'))
            cf.write("client_id = %s\n" % AUTH_DATA['client_id'])

        with self.assertRaises(SystemExit) as exc, self.assertLogs() as logs:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_PREFIX)
            mdc.get_jwt_token()
        self.assertIn("ERROR:malware_detection_client:401", " ".join(logs.output))
        self.assertEqual(exc.exception.code, 1)

    @responses.activate
    def test_upload_host_scan(self):
        # Scan the tests directory & get a list of all the discovered string_data
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_PREFIX)
        mdc.scan_filesystem()
        mdc.upload_host_scan()
        host_scan_string_data = []
        for match in mdc.host_scan:
            host_scan_string_data.extend(set(map(lambda x: x['string_data'], mdc.host_scan[match])))

        # Expect each of teh string_data elements to be in the host_scan string_data fields
        # And to be JSON encoded in the host_scan_mutation
        for sd in STRING_DATA:
            self.assertIn(sd, host_scan_string_data)
            self.assertIn(json.dumps(sd), mdc.host_scan_mutation)

        # Make sure the unencoded string_data isn't in the host_scan_mutation
        for sd in STRING_DATA[1:]:
            self.assertNotIn(sd, mdc.host_scan_mutation)


if __name__ == '__main__':
    unittest.main()
