import unittest2
from malware_detection_client import MalwareDetectionClient
from test_constants import *


class TestMalwareDetectionClient(unittest2.TestCase):

    def setUp(self):
        # Create a conf file to be used throughout the tests.  Includes the rule_location and results_url.
        remove_conf_file()
        with self.assertRaises(SystemExit):
            MalwareDetectionClient(create_conf=True, conf_file=CONF_FILE, **LOCATION_PARAMS)

    def tearDown(self):
        remove_conf_file()

    def assert_defaults(self, mdc):
        self.assertTrue(mdc.yara_binary in ['/usr/local/bin/yara', '/usr/bin/yara', '/bin/yara'])
        self.assertEqual(mdc.rules_file, TEST_RULES_COMPILED)
        self.assertEqual(mdc.compiled_rules_flag, '-C')
        self.assertEqual(mdc.do_filesystem_scan, True)
        self.assertEqual(mdc.do_process_scan, True)
        self.assertFalse(hasattr(mdc, 'scan_fsobjects'))
        self.assertFalse(hasattr(mdc, 'scan_pids'))
        self.assertEqual(mdc.results_url, TEST_RESULTS_URL)

    def test_default_options(self):
        # When writing a new/default conf file, then errors occur because the rule and result locations aren't populated
        try:
            default_conf_file = '/tmp/test_default_malware_detection_client_%s.conf' % get_random_string()
            if os.path.exists(default_conf_file):
                os.remove(default_conf_file)
            # Client exits after creating a conf, so catch that
            with self.assertRaises(SystemExit):
                MalwareDetectionClient(create_conf=True, conf_file=default_conf_file)

            # No rule location specified, so exit with error
            with self.assertRaises(SystemExit) as exc, self.assertLogs() as log:
                mdc = MalwareDetectionClient(conf_file=default_conf_file)
            self.assertIn("ERROR:malware_detection_client:No location specified from which to retrieve the rules, exiting",
                          log.output)
            self.assertEqual(exc.exception.code, 1)

            # Now we specify a rule_location but no results location, so exit with error about results location
            with self.assertRaises(SystemExit) as exc, self.assertLogs() as log:
                mdc = MalwareDetectionClient(conf_file=default_conf_file, rules_location=TEST_RULES_COMPILED)
            self.assertIn("ERROR:malware_detection_client:No location specified to which to upload results, exiting",
                          log.output)
            self.assertEqual(exc.exception.code, 1)
        finally:
            if os.path.exists(default_conf_file):
                os.remove(default_conf_file)

        # With the conf file we created earlier, there is no error because we supplied a rules_location and results_url
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, debug=True)
        self.assert_defaults(mdc)

    def test_modified_options(self):
        # The self.conf_file has rules and results locations populated, so expect no errors
        mdc = MalwareDetectionClient(conf_file=CONF_FILE)
        self.assertEqual(mdc.rules_file, TEST_RULES_COMPILED)
        self.assertEqual(mdc.compiled_rules_flag, '-C')
        self.assertEqual(mdc.do_filesystem_scan, True)
        self.assertEqual(mdc.do_process_scan, True)
        self.assertFalse(hasattr(mdc, 'scan_fsobjects'))
        self.assertFalse(hasattr(mdc, 'scan_pids'))

        # Use a text rules file, expect the compiled_rules_flag is empty
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, rules_location=TEST_RULE1)
        self.assertEqual(mdc.rules_file, TEST_RULE1)
        self.assertEqual(mdc.compiled_rules_flag, '')

        # Test scanning just a PID, expect just the do_process_scan to be True
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity='1')
        self.assertEqual(mdc.do_filesystem_scan, False)
        self.assertEqual(mdc.do_process_scan, True)
        self.assertFalse(hasattr(mdc, 'scan_fsobjects'))
        self.assertEqual(mdc.scan_pids, [1])

        # Test scanning just a file, expect just the do_filesystems_scan to be True
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_CLIENT)
        self.assertEqual(mdc.do_filesystem_scan, True)
        self.assertEqual(mdc.do_process_scan, False)
        self.assertEqual(mdc.scan_fsobjects, [TEST_CLIENT])
        self.assertFalse(hasattr(mdc, 'scan_pids'))

    def test_scanning_tests_files(self):
        # Test scanning the compiled rules file
        with self.assertLogs() as logs:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_RULES_COMPILED)
            mdc.scan_filesystem()
        self.assertIn("INFO:malware_detection_client:Scan argument: file %s" % TEST_RULES_COMPILED, logs.output)
        self.assertIn("INFO:malware_detection_client:Getting rules from %s" % TEST_RULES_COMPILED, logs.output)
        self.assertIn("INFO:malware_detection_client:Scanning %s ..." % TEST_RULES_COMPILED, logs.output)
        self.assertIn("INFO:malware_detection_client:Matched rule MalwareDetectionClientRule in file %s"
                      % TEST_RULES_COMPILED, logs.output)
        self.assertIn("INFO:malware_detection_client:Matched rule MiscellaneousStringsRule in file %s"
                      % TEST_RULES_COMPILED, logs.output)
        # Matched 2 rules
        self.assertEqual(mdc.matches, 2)
        # Matched rule strings 3 times
        string_matches = sum([len(mdc.host_scan[x]) for x in mdc.host_scan])
        self.assertEqual(string_matches, 3)
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        self.assertEqual(rule_match[0]['source'], TEST_RULES_COMPILED)
        self.assertEqual(rule_match[0]['string_data'], ' MalwareDetectionClient')
        self.assertEqual(rule_match[0]['string_identifier'], '$text1')
        self.assertAlmostEqual(rule_match[0]['string_offset'], 500, delta=200)
        rule_match = mdc.host_scan['MiscellaneousStringsRule']
        self.assertEqual(rule_match[0]['source'], TEST_RULES_COMPILED)
        self.assertEqual(rule_match[0]['string_data'], ' sent"')
        self.assertEqual(rule_match[0]['string_identifier'], '$string1')
        self.assertAlmostEqual(rule_match[0]['string_offset'], 500, delta=200)
        self.assertEqual(rule_match[1]['source'], TEST_RULES_COMPILED)
        self.assertEqual(rule_match[1]['string_data'], ' ata_sff\\x00bioset\\x00bond0\\x00cifsd\\x00')
        self.assertEqual(rule_match[1]['string_identifier'], '$string2')
        self.assertAlmostEqual(rule_match[1]['string_offset'], 500, delta=200)
        self.assertFalse(mdc.scan_processes())

        # Test scanning this test_malware_detection_client.py file.  Expect to find 10 matches (with string_match_limit set to 10)
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_CLIENT)
        self.assertEqual(mdc.string_match_limit, 10)
        mdc.scan_filesystem()
        self.assertEqual(mdc.matches, 2)  # Matches the two rules
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        self.assertEqual(len(rule_match), 10)  # Because string_match_limit = 10
        self.assertEqual(rule_match[0]['source'], TEST_CLIENT)
        self.assertEqual(rule_match[0]['string_data'], ' MalwareDetectionClient')
        self.assertEqual(rule_match[0]['string_identifier'], '$text1')
        # First match is near the start of the file
        self.assertAlmostEqual(rule_match[0]['string_offset'], 200, delta=200)

        # Increase string_match_limit and scan again.  Expect to find more than 10 matches
        mdc.string_match_limit = 100
        mdc.scan_filesystem()
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        self.assertGreater(len(rule_match), 10)

    def test_scanning_tests_directory(self):
        # Test scanning all the files in the tests directory
        with self.assertLogs() as logs:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_PREFIX)
            mdc.scan_filesystem()
        self.assertIn("INFO:malware_detection_client:Scan argument: directory %s" % TEST_PREFIX, logs.output)
        self.assertIn("INFO:malware_detection_client:Getting rules from %s" % TEST_RULES_COMPILED, logs.output)
        self.assertIn("INFO:malware_detection_client:Scanning %s ..." % TEST_PREFIX, logs.output)
        self.assertIn("INFO:malware_detection_client:Matched rule MalwareDetectionClientRule in file %s"
                      % TEST_RULE1, logs.output)
        self.assertIn("INFO:malware_detection_client:Matched rule MiscellaneousStringsRule in file %s"
                      % TEST_RULE2, logs.output)
        # By default, skip the rules file (TEST_RULES_COMPILED) because it will cause matches
        self.assertNotIn(TEST_RULES_COMPILED, logs.output)

        # Expect 7 matches ...
        # - MalwareDetectionClientRule to match test_rule1 and the 3 test_* files
        # - MiscellaneousStringsRule to match test_rule2 and test_client and test_network
        self.assertEqual(mdc.matches, 7)
        # Expect MalwareDetectionClientRule to match 1 string in test_rule1
        # and > 10 strings in test_malware_detection_client & multiple in the other test_* files
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        rule_match_sources = [rm['source'] for rm in rule_match]
        self.assertIn(TEST_RULE1, rule_match_sources)
        self.assertEqual(len(list(filter(lambda x: x == TEST_RULE1, rule_match_sources))), 1)
        self.assertIn(TEST_CLIENT, rule_match_sources)
        self.assertEqual(len(list(filter(lambda x: x == TEST_CLIENT, rule_match_sources))), 10)
        self.assertIn(TEST_PARSE, rule_match_sources)
        self.assertGreaterEqual(len(list(filter(lambda x: x == TEST_PARSE, rule_match_sources))), 5)
        self.assertIn(TEST_NETWORK, rule_match_sources)
        self.assertGreaterEqual(len(list(filter(lambda x: x == TEST_NETWORK, rule_match_sources))), 5)
        self.assertNotIn(TEST_RULE2, rule_match_sources)

        # Expect MiscellaneousStringsRule to match 2 strings in test_rule2
        # and >= 1 strings in test_malware_detection_client & test_network_functions
        rule_match = mdc.host_scan['MiscellaneousStringsRule']
        rule_match_sources = [rm['source'] for rm in rule_match]
        self.assertIn(TEST_RULE2, rule_match_sources)
        self.assertEqual(len(list(filter(lambda x: x == TEST_RULE2, rule_match_sources))), 2)
        self.assertIn(TEST_CLIENT, rule_match_sources)
        self.assertEqual(len(list(filter(lambda x: x == TEST_CLIENT, rule_match_sources))), 1)
        self.assertIn(TEST_NETWORK, rule_match_sources)
        self.assertEqual(len(list(filter(lambda x: x == TEST_NETWORK, rule_match_sources))), 1)
        self.assertNotIn(TEST_PARSE, rule_match_sources)
        self.assertNotIn(TEST_RULE1, rule_match_sources)

    def test_scanning_unittest_process(self):
        # Scan the process that is running the tests
        test_pid = str(os.getpid())
        with self.assertLogs() as logs:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=test_pid)
        self.assertIn("INFO:malware_detection_client:Scan argument: pid %s" % test_pid, logs.output)

        self.assertFalse(mdc.scan_filesystem())
        with self.assertLogs() as logs:
            mdc.scan_processes()
        self.assertIn("INFO:malware_detection_client:Scanning pid %s ..." % test_pid, logs.output)
        self.assertIn("INFO:malware_detection_client:Matched rule MalwareDetectionClientRule in PID %s" % test_pid,
                      logs.output)
        # Matches both rules in the PID
        self.assertEqual(mdc.matches, 2)
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        self.assertEqual(len(rule_match), 10)
        self.assertEqual(rule_match[0]['source'], test_pid)
        self.assertEqual(rule_match[0]['string_data'], ' MalwareDetectionClient')
        self.assertEqual(rule_match[0]['string_identifier'], '$text1')
        self.assertGreater(rule_match[0]['string_offset'], 0)


if __name__ == '__main__':
    unittest2.main()
