from malware_detection_client import MalwareDetectionClient
from .constants import *
import pytest
import hashlib
import fileinput


class TestMalwareDetectionClient:

    def test_default_options(self, caplog):
        # When creating a new conf file, there will be errors if the rules and results locations aren't populated
        # (Note, this test ignores the new conf file created by the prep_conf_file fixture)
        new_conf_file = '/tmp/test_default_malware_detection_client_%s.conf' % get_random_string()
        try:
            # Start off by writing a new conf file with the rules and results locations populated
            # Note, malware-detection-client.py exits after creating a new conf file, so catch that
            with pytest.raises(SystemExit):
                MalwareDetectionClient(new_conf_file=new_conf_file, **LOCATION_PARAMS)
            conf_file_contents = open(new_conf_file).read()
            assert "rules_location=" + RULES_COMPILED in conf_file_contents
            assert "results_location=http://127.0.0.1/graphql" in conf_file_contents

            # Overwrite the new conf file created just before, but with missing rules and results locations
            # No errors or messages will be created for overwriting the existing configuration file
            with pytest.raises(SystemExit):
                MalwareDetectionClient(new_conf_file=new_conf_file)
            conf_file_contents = open(new_conf_file).read()
            assert "rules_location=" + RULES_COMPILED not in conf_file_contents
            assert "results_location=http://127.0.0.1/graphql" not in conf_file_contents

            # Try to use the new conf file, however with no rules_location specified, it will exit with an error
            caplog.clear()
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient(conf_file=new_conf_file)
            assert "ERROR:Please check that 'rules_location' has a value in the configuration file" in caplog.text
            assert exc_info.value.code == 1

            # Now we specify a rules_location but still no results_location, so exit with error about results_location
            caplog.clear()
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient(conf_file=new_conf_file, rules_location=RULES_COMPILED)
            assert "ERROR:Please check that 'results_location' has a value in the configuration file" in caplog.text
            assert exc_info.value.code == 1

            # Specify both a rule_location and results_location - it won't exit with an error this time
            caplog.clear()
            MalwareDetectionClient(conf_file=new_conf_file, debug=True, **LOCATION_PARAMS)
            assert "INFO:Getting the rules from 'tests/rules_compiled.yar'" in caplog.text
            assert "DEBUG:Scan results will be uploaded to http://127.0.0.1/graphql" in caplog.text
        finally:
            remove_conf_file(conf_file=new_conf_file)

    def test_unreadable_conf_files(self, caplog):
        conf_file = '/etc/malware-detection-client/malware-detection-client.conf'
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient(conf_file=conf_file)
        assert "ERROR:Unable to read configuration file '%s'." % conf_file in caplog.text
        assert exc_info.value.code == 1

        caplog.clear()
        conf_file = '/etc/malware-detection-client'
        with pytest.raises(SystemExit):
            MalwareDetectionClient(conf_file=conf_file)
        assert "ERROR:Unable to read configuration file '%s'." % conf_file in caplog.text
        assert exc_info.value.code == 1

        caplog.clear()
        conf_file = 'data/fred.conf'
        with pytest.raises(SystemExit):
            MalwareDetectionClient(conf_file=conf_file)
        assert "ERROR:Unable to read configuration file '%s'." % conf_file in caplog.text
        assert exc_info.value.code == 1

    def test_conf_file_fixture(self):
        # With the conf file created by the fixture, these are the expected values
        # and there will be no errors because we supply the rules_location and results_url
        mdc = MalwareDetectionClient(conf_file=CONF_FILE)
        assert mdc.yara_binary in ['/usr/local/bin/yara', '/usr/bin/yara', '/bin/yara']
        assert mdc.nice_binary in ['/usr/bin/nice', '/bin/nice']
        assert mdc.yara_cmd[:8] == [mdc.nice_binary, '-n', str(mdc.nice), mdc.yara_binary, '-s', '-N', '-a',
                                    str(mdc.scan_timeout)]
        assert mdc.rules_file == RULES_COMPILED
        assert mdc.results_url == RESULTS_URL
        assert mdc.compiled_rules_flag == '-C'
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is True
        assert not hasattr(mdc, 'scan_fsobjects')
        assert not hasattr(mdc, 'scan_pids')

    def test_modified_options(self):
        # Using the conf file from the fixture but with different options
        # Use a text rules file, expect the compiled_rules_flag is empty
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, rules_location=RULE1)
        assert mdc.rules_file == RULE1
        assert mdc.compiled_rules_flag == ''

        # Test scanning just a PID, expect just the do_process_scan to be True
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity='1')
        assert mdc.do_filesystem_scan is False
        assert mdc.do_process_scan is True
        assert not hasattr(mdc, 'scan_fsobjects')
        assert mdc.scan_pids == [1]

        # Test scanning just a file, expect just the do_filesystems_scan to be True
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_CLIENT)
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is False
        assert mdc.scan_fsobjects == [TEST_CLIENT]
        assert not hasattr(mdc, 'scan_pids')

    def test_scan_option_entire_filesystem(self, caplog):
        # -s / option used - expect a message and scan_fsobjects to contain all top level dirs, including
        # some directories that probably shouldn't be scanned, eg /dev, /mnt, /proc, /sys
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity='/')
        assert mdc.do_filesystem_scan is True
        assert mdc.do_process_scan is False
        assert "WARNING:The root directory '/' was specified to be scanned (not recommended)" in caplog.text
        assert all([toplevel_dir in mdc.scan_fsobjects for toplevel_dir in
                    ['/dev', '/etc', '/home', '/mnt', '/proc', '/root', '/sys', '/tmp', '/usr', '/var']])
        assert not hasattr(mdc, 'scan_pids')

    def test_scanning_compiled_rules_file(self, caplog):
        # Scan the compiled rules file ... with the compiled rules file
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=RULES_COMPILED)
        mdc.scan_filesystem()
        assert "Scan argument: file %s" % RULES_COMPILED in caplog.text
        assert "Getting the rules from '%s'" % RULES_COMPILED in caplog.text
        assert "Scanning %s ..." % RULES_COMPILED in caplog.text
        assert "Matched rule MalwareDetectionClientRule in file %s" % RULES_COMPILED in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % RULES_COMPILED in caplog.text
        # Matched 2 rules
        assert mdc.matches == 2
        # Matched rule strings 3 times
        string_matches = sum([len(mdc.host_scan[x]) for x in mdc.host_scan])
        assert string_matches == 3

        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert rule_match[0]['source'] == RULES_COMPILED
        assert rule_match[0]['string_data'] == 'MalwareDetectionClient'
        assert rule_match[0]['string_identifier'] == '$text1'
        assert rule_match[0]['string_offset'] <= 544

        rule_match = mdc.host_scan['MiscellaneousStringsRule']
        assert rule_match[0]['source'] == RULES_COMPILED
        assert rule_match[0]['string_data'] == 'sent"'
        assert rule_match[0]['string_identifier'] == '$string1'
        assert rule_match[0]['string_offset'] == 601
        assert rule_match[1]['source'] == RULES_COMPILED
        assert rule_match[1]['string_data'] == 'ata_sff\\x00bioset\\x00bond0\\x00cifsd\\x00'
        assert rule_match[1]['string_identifier'] == '$string2'
        assert rule_match[1]['string_offset'] == 616
        assert mdc.scan_processes() is False

        # Scan this test_malware_detection_client.py file
        # Expect to find 10 matches (because string_match_limit set to 10)
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_CLIENT)
        assert mdc.string_match_limit == 10
        mdc.scan_filesystem()
        assert mdc.matches == 2  # Matches the two rules
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert len(rule_match) == 10  # Because string_match_limit = 10
        assert rule_match[0]['source'] == TEST_CLIENT
        assert rule_match[0]['string_data'] == 'MalwareDetectionClient'
        assert rule_match[0]['string_identifier'] == '$text1'
        # First match is near the start of the file
        assert rule_match[0]['string_offset'] < 200

        # Increase string_match_limit and scan again.  Expect to find more than 10 matches
        mdc.string_match_limit = 100
        mdc.scan_filesystem()
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert len(rule_match) > 10

    def test_rules_file_types(self, caplog):
        # Testing if the rules file is compiled or not
        for rules_file in [RULE_RULE, RULE_TEST_RHIMD, RULE1, RULE2]:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, rules_location=rules_file, debug=True)
            assert mdc.compiled_rules_flag == ''
            assert 'Compiled rules: False' in caplog.text
            caplog.clear()

        mdc = MalwareDetectionClient(conf_file=CONF_FILE, rules_location=RULES_COMPILED, debug=True)
        assert mdc.compiled_rules_flag == '-C'
        assert 'Compiled rules: True' in caplog.text

    def test_bad_rules_files(self, caplog):
        # Tests with problematic rules files
        for rules_file in [TEST_CLIENT, TEST_DIR + '/tmp_scan_files.tgz']:
            with pytest.raises(SystemExit) as exc_info:
                MalwareDetectionClient(conf_file=CONF_FILE, rules_location=rules_file)
            assert "ERROR:Unable to use rules file '%s'" % rules_file in caplog.text
            assert exc_info.value.code == 1
            caplog.clear()

        caplog.clear()
        rules_file = TEST_DIR
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient(conf_file=CONF_FILE, rules_location=rules_file)
        assert "ERROR:Couldn't find rules file '%s'" % rules_file in caplog.text
        assert exc_info.value.code == 1

        caplog.clear()
        rules_file = TEST_DIR + '/__init__.py'
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient(conf_file=CONF_FILE, rules_location=rules_file)
        assert "ERROR:Rules file '%s' is empty" % rules_file in caplog.text
        assert exc_info.value.code == 1

    def test_scanning_tests_directory(self, caplog):
        # Test scanning all the files in the tests directory
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR)
        mdc.scan_filesystem()
        assert "Scan argument: directory %s" % TEST_DIR in caplog.text
        assert "Getting the rules from '%s'" % RULES_COMPILED in caplog.text
        assert "Scanning %s ..." % TEST_DIR in caplog.text
        assert "Matched rule MalwareDetectionClientRule in file %s" % RULE1 in caplog.text
        assert "Matched rule MiscellaneousStringsRule in file %s" % RULE2 in caplog.text
        # By default, there will be no rules matched in RULES_COMPILED because we skip it
        # (It's the rules_file so naturally it would cause matches)
        assert "in file %s" % RULES_COMPILED not in caplog.text

        # Expect 10 matches ...
        # - MalwareDetectionClientRule to match rule1.yar, TEST_RedHat*.yar, conftest and the 4 test_* files
        # - MiscellaneousStringsRule to match rule2.yar, test_*client and test_network*
        assert mdc.matches == 10
        # Expect MalwareDetectionClientRule to match 1 string in test_rule1
        # and > 10 strings in test_malware_detection_client & multiple in the other test_* files
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        rule_match_sources = [rm['source'] for rm in rule_match]
        assert RULE1 in rule_match_sources
        # RULE1 appears once in all the source fields
        assert len(list(filter(lambda x: x == RULE1, rule_match_sources))) == 1
        assert TEST_CLIENT in rule_match_sources
        assert len(list(filter(lambda x: x == TEST_CLIENT, rule_match_sources))) == 10
        assert TEST_PARSE in rule_match_sources
        assert len(list(filter(lambda x: x == TEST_PARSE, rule_match_sources))) > 5
        assert TEST_NETWORK in rule_match_sources
        assert len(list(filter(lambda x: x == TEST_NETWORK, rule_match_sources))) > 5
        assert RULE_TEST_RHIMD in rule_match_sources
        assert len(list(filter(lambda x: x == RULE_TEST_RHIMD, rule_match_sources))) == 1
        assert RULE2 not in rule_match_sources

        # Assert all rule_matches have a metadata field
        assert all([rm.get('metadata') for rm in rule_match])

        # Expect MiscellaneousStringsRule to match 2 strings in test_rule2
        # and >= 1 strings in test_malware_detection_client & test_network_functions
        rule_match = mdc.host_scan['MiscellaneousStringsRule']
        rule_match_sources = [rm['source'] for rm in rule_match]
        assert RULE2 in rule_match_sources
        assert len(list(filter(lambda x: x == RULE2, rule_match_sources))) == 2
        assert TEST_CLIENT in rule_match_sources
        assert len(list(filter(lambda x: x == TEST_CLIENT, rule_match_sources))) == 3
        assert TEST_NETWORK in rule_match_sources
        assert len(list(filter(lambda x: x == TEST_NETWORK, rule_match_sources))) == 1
        assert TEST_PARSE not in rule_match_sources
        assert RULE1 not in rule_match_sources

        # Assert all rule_matches have a metadata field
        assert all([rm.get('metadata') for rm in rule_match])

    def test_skip_rules_file_with_extra_slashes(self, caplog):
        # Test scanning the tests directory again, but with an extra slash in the RULES_COMPILED path
        # Even with the extra slash in RULES_COMPILED, there should be no rules matched in RULES_COMPILED
        # because tests/rules_compiled.yar and tests//rules_compiled.yar are the same file
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, rules_location=RULES_COMPILED.replace('/', '//'),
                                     scan_entity=TEST_DIR)
        mdc.scan_filesystem()
        assert "in file %s" % RULES_COMPILED not in caplog.text

    def test_scan_files_metadata(self):
        # Test scanning various test files and get their metadata
        # Test metadata for tests/test_malware_detection_client.py
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_CLIENT)
        assert mdc.metadata
        mdc.scan_filesystem()

        # Expect all rule_matches to have a metadata field
        for rule in ('MalwareDetectionClientRule', 'MiscellaneousStringsRule'):
            rule_match = mdc.host_scan[rule]
            assert all(['metadata' in rm.keys() for rm in rule_match])

        rule_match = sorted(mdc.host_scan['MalwareDetectionClientRule'], key=lambda k: k['string_offset'])
        assert rule_match[0]['source'] == TEST_CLIENT
        assert rule_match[0]['string_data'] == 'MalwareDetectionClient'
        assert rule_match[0]['string_identifier'] == '$text1'
        assert rule_match[0]['string_offset'] == 37
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'Python script, ASCII text executable'
        assert metadata['mime_type'] in ['text/x-python; charset=us-ascii', 'text/x-script.python; charset=us-ascii']
        assert metadata['md5sum'] == hashlib.md5(open(TEST_CLIENT, 'rb').read()).hexdigest()
        assert metadata['line_number'] == 1
        assert metadata['line'] == 'from%20malware_detection_client%20import%20MalwareDetectionClient'
        assert 'process_name' not in metadata.keys()

        # Test metadata for tests/test_network_functions.py
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_NETWORK)
        mdc.scan_filesystem()
        rule_match = sorted(mdc.host_scan['MiscellaneousStringsRule'], key=lambda k: k['string_offset'])
        assert rule_match[0]['source'] == TEST_NETWORK
        assert rule_match[0]['string_data'] == 'sent"'
        assert rule_match[0]['string_identifier'] == '$string1'
        assert 500 <= rule_match[0]['string_offset'] <= 1000
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['file_type'] == 'Python script, ASCII text executable'
        assert metadata['mime_type'] in ['text/x-python; charset=us-ascii', 'text/x-script.python; charset=us-ascii']
        assert metadata['md5sum'] == hashlib.md5(open(TEST_NETWORK, 'rb').read()).hexdigest()
        assert 20 <= metadata['line_number'] <= 50
        assert metadata['line'].startswith(urlencode("STRING_DATA = ['MalwareDetectionClient', 'sent"))

        # Test metadata for tests/rules_compiled.yar - its a binary file so expect no line numbers or lines
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=RULES_COMPILED)
        mdc.scan_filesystem()
        rule_match = sorted(mdc.host_scan['MalwareDetectionClientRule'], key=lambda k: k['string_offset'])
        assert rule_match[0]['source'] == RULES_COMPILED
        assert rule_match[0]['string_data'] == 'MalwareDetectionClient'
        assert rule_match[0]['string_identifier'] == '$text1'
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'file'
        assert metadata['mime_type'] == 'application/octet-stream; charset=binary'
        assert metadata['md5sum'] == hashlib.md5(open(RULES_COMPILED, 'rb').read()).hexdigest()
        assert all([key not in ['line_number', 'line'] for key in metadata.keys()])

    def test_metadata_false(self):
        # Test scanning files and processes but not gathering metadata
        # Firstly, set metadata=False in the config file
        for line in fileinput.FileInput(CONF_FILE, inplace=1):
            if "metadata=" in line:
                line = line.replace(line, "metadata=False")
            print(line)

        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_CLIENT)
        assert not mdc.metadata
        mdc.scan_filesystem()
        # The rule_matches will still have a metadata field containing the source_type, but no other metadata fields
        for rule in ('MalwareDetectionClientRule', 'MiscellaneousStringsRule'):
            rule_match = mdc.host_scan[rule]
            for rm in rule_match:
                assert 'metadata' in rm.keys()
                assert len(rm['metadata']) == 1
                assert 'source_type' in rm['metadata']
                assert rm['metadata']['source_type'] == 'file'
                assert 'file_type' not in rm['metadata']

        # Scan the python pytest process whilst its running the tests
        test_pid = str(os.getpid())
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=test_pid)
        assert not mdc.metadata
        mdc.scan_processes()
        # Again, the rule_matches will have a metadata field containing the source_type, but no other metadata fields
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        for rm in rule_match:
            assert 'metadata' in rm.keys()
            assert len(rm['metadata']) == 1
            assert 'source_type' in rm['metadata']
            assert rm['metadata']['source_type'] == 'process'
            assert 'process_name' not in rm['metadata']

    def test_exclude_rules(self, caplog):
        # Exclude rules when scanning the tests directory
        # Firstly, exclude the rule MalwareDetectionClientRule and verify it doesn't appear in the scan results
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR, debug=True,
                                     exclude_rules='MalwareDetectionClient')
        assert "INFO:Rules to exclude: MalwareDetectionClient" in caplog.text
        mdc.scan_filesystem()
        assert "Matched rule MalwareDetectionClientRule" not in caplog.text
        assert "Matched rule MiscellaneousStringsRule" in caplog.text
        # Expect only 3 matches this time ...
        # - MiscellaneousStringsRule to match test_rule2, test_*client and test_network*
        assert mdc.matches == 3
        assert 'MalwareDetectionClientRule' not in mdc.host_scan.keys()
        assert 'MiscellaneousStringsRule' in mdc.host_scan.keys()

        # Now exclude both rules and verify there are no scan matches
        caplog.clear()
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR, debug=True,
                                     exclude_rules='MalwareDetectionClient,MiscellaneousStrings')
        assert "INFO:Rules to exclude: MalwareDetectionClient, MiscellaneousStrings" in caplog.text
        mdc.scan_filesystem()
        assert mdc.matches == 0
        assert mdc.host_scan == {}

        # This also works - exclude both rules by just specifying the letter 'm'
        # It will match any rule name in lowercase that contains the letter 'm'
        caplog.clear()
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR, debug=True, exclude_rules='m')
        assert "INFO:Rules to exclude: m" in caplog.text
        mdc.scan_filesystem()
        assert mdc.matches == 0
        assert mdc.host_scan == {}

        # Verify we don't exclude any rules when specifying 'x, y, z'
        caplog.clear()
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR, debug=True, exclude_rules='x, y, z')
        assert "INFO:Rules to exclude: x, y, z" in caplog.text
        mdc.scan_filesystem()
        assert mdc.matches == 10
        assert sorted(['MalwareDetectionClientRule', 'MiscellaneousStringsRule']) == sorted(mdc.host_scan.keys())

        # Contrived example to test parsing the list of excluded rule names passed in
        caplog.clear()
        MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR, debug=True,
                               exclude_rules=',fred  ,  barney,,,,wilma, ')
        assert "INFO:Rules to exclude: fred, barney, wilma" in caplog.text

    def test_scanning_pytest_process(self, caplog):
        # Scan the python pytest process whilst its running the tests
        test_pid = str(os.getpid())
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=test_pid)
        assert "Scan argument: process %s" % test_pid in caplog.text

        assert mdc.scan_filesystem() is False
        mdc.scan_processes()
        assert "Scanning process %s ..." % test_pid in caplog.text
        assert "Matched rule MalwareDetectionClientRule in process %s" % test_pid in caplog.text
        # Matches both rules in the PID
        assert mdc.matches == 2
        rule_match = mdc.host_scan['MalwareDetectionClientRule']
        assert len(rule_match) == 10
        assert rule_match[0]['source'] == test_pid
        assert rule_match[0]['string_data'] == 'MalwareDetectionClient'
        assert rule_match[0]['string_identifier'] == '$text1'
        assert rule_match[0]['string_offset'] > 0
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'process'
        assert all(['metadata' in rm.keys() for rm in rule_match])

    def test_pytest_process_metadata(self):
        # Scan the python pytest process whilst its running the tests
        test_pid = str(os.getpid())
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=test_pid)
        assert mdc.scan_filesystem() is False
        mdc.scan_processes()

        # Expect all rule_matches to have a metadata field since it was enabled
        for rule in ('MalwareDetectionClientRule', 'MiscellaneousStringsRule'):
            rule_match = mdc.host_scan[rule]
            assert all(['metadata' in rm.keys() for rm in rule_match])

        rule_match = sorted(mdc.host_scan['MalwareDetectionClientRule'], key=lambda k: k['string_offset'])
        assert rule_match[0]['source'] == test_pid
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'process'
        # The process running the tests should have any of these strings in its name
        assert any([s in metadata['process_name'] for s in ('python', 'pytest', 'tests')])
        # Check that file related metadata keys are not present
        assert all([key not in ['file_type', 'md5sum', 'line_number'] for key in metadata.keys()])

    def test_filenames_containing_spaces(self, caplog):
        # Check that filenames with spaces in them are handled ok
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, rules_location=RULE_RULE,
                                     scan_entity=ANOTHER_MATCHING_ENTITY_FILE, debug=True)
        mdc.scan_filesystem()
        assert "ERROR:Unable to scan 'tests/another matching_entity'" not in caplog.text
        assert ("DEBUG:Yara command: %s -n 19 %s -s -N -a 3600 -p %s -r tests/rule rule.yar tests/another matching_entity"
                % (mdc.nice_binary, mdc.yara_binary, mdc.cpu_thread_limit)) in caplog.text

        caplog.clear()
        # For completeness, verify that filenames without spaces work ok too
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR, debug=True)
        mdc.scan_filesystem()
        assert ("DEBUG:Yara command: %s -n 19 %s -s -N -a 3600 -p %s -r -C tests/rules_compiled.yar tests"
                % (mdc.nice_binary, mdc.yara_binary, mdc.cpu_thread_limit)) in caplog.text
