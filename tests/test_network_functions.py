from malware_detection_client import MalwareDetectionClient, utils
from .constants import *
import pytest
import json
import jwt
from datetime import datetime
import responses
import fileinput
import re
from hashlib import md5
try:
    # Python 3
    from urllib.parse import parse_qsl
    from unittest.mock import patch, mock_open
    open_func = "builtins.open"
except ImportError:
    # Python 2
    from urlparse import parse_qsl
    from mock import patch, mock_open
    open_func = "__builtin__.open"

# The string_data matches we expect to find in the files in this test directory
# Elements [1:] (from the second element onwards) need to be escaped in the mutation before uploading
STRING_DATA = ['MalwareDetectionClient', 'sent"', 'ata_sff\\x00bioset\\x00bond0\\x00cifsd\\x00']

# Test authentication data that is 'sent' to keycloak
# And the token that is 'returned' from keycloak (it's expiry date is set to now, meaning it expires immediately)
AUTH_DATA = {
    'keycloak_url': KEYCLOAK_URL,
    'client_id': 'client',
    'username': 'testing',
    'password': '123',
    'token': {'keycloak_url_hash': md5(KEYCLOAK_URL.encode('utf-8')).hexdigest(),
              'id_token': jwt.encode(payload=dict(exp=datetime.utcnow()), key=""),  # token expires immediately
              'refresh_token': 'not_currently_used'}
}

# Various error messages returned from the API
# For unknown insights id when uploading the results
INVALID_ID_ERROR_HINT = 'Make sure the system has been registered with the insights-client'
INVALID_ID_ERROR_MESSAGE = 'Nonexistent insights_id --> %s' % INVALID_INSIGHTS_ID
# For sending a bad UUID value
BAD_UUID_ERROR_MESSAGE = 'Expected value of type "UUID", found "BAD UUID"; Invalid UUID'


def simulate_keycloak_response(request):
    """
    For simulating sending authentication data to the keycloak server
    and its response depending on what was sent
    """
    data = dict(parse_qsl(request.body))
    if any([auth_type for auth_type in ['username', 'password'] if data[auth_type] != AUTH_DATA[auth_type]]):
        # Missing or incorrect username/password in request
        return 401, {}, json.dumps({"error": "invalid_grant", "error_description": "Invalid user credentials"})
    elif data['client_id'] != AUTH_DATA['client_id']:
        # Missing or incorrect client_id in request
        return 400, {}, json.dumps({"error": "unauthorized_client", "error_description": "Invalid client credentials"})
    else:
        return 200, {}, json.dumps(AUTH_DATA['token'])


def simulate_graphql_response(request):
    """
    For simulating sending the host scan mutation to the graphql endpoint and its successful response
    """
    data = json.loads(request.body)
    if 'mutation' in data.get('query', ''):
        if 'TEST_RedHatInsightsMalwareDetection' not in data['query']:
            # Only check these assertions if not processing the test rule
            for sd in STRING_DATA[1:]:
                assert sd not in data['query']
                assert json.dumps(sd) in data['query']
        return 200, {}, json.dumps({'recordHostScan': {'success': True}})
    else:
        return 200, {}, json.dumps({'query': {'success': True}})


def simulate_graphql_query_response(request):
    """
    Simulate sending queries and mutations to the API and the expected responses
    """
    query = json.loads(request.body).get('query', '')
    if 'mutation HostScan' in query:
        if INVALID_INSIGHTS_ID in query:
            return 200, {}, json.dumps(
                {'errors': [{'hint': INVALID_ID_ERROR_HINT,
                             'message': INVALID_ID_ERROR_MESSAGE}]}
            )
        elif "BAD UUID" in query:
            return 200, {}, json.dumps(
                {"errors": [{"message": BAD_UUID_ERROR_MESSAGE}]}
            )
        return 200, {}, json.dumps({'recordHostScan': {'success': True}})


def simulate_rule_response(request):
    # Simulate returning a rules file from the backend
    if 'test-rule' in request.path_url:
        return 200, {}, open(RULE_TEST_RHIMD, 'rb').read()
    else:
        return 200, {}, open(RULES_COMPILED, 'rb').read()


@pytest.fixture(scope="function", autouse=True)
def setup_responses():
    """
    Fake the sending of requests to these URLs and instead, call the callback functions
    """
    responses.add_callback(responses.POST, KEYCLOAK_URL, callback=simulate_keycloak_response)
    responses.add_callback(responses.POST, RESULTS_URL, callback=simulate_graphql_response)
    responses.add_callback(responses.POST, CRC_URL, callback=simulate_graphql_query_response)
    responses.add_callback(responses.GET, re.compile('(%s|%s)' % (CRC_RULE_URL, TEST_RULE_URL)),
                           callback=simulate_rule_response)


@pytest.fixture(scope="function", autouse=False)
def add_keycloak_auth():
    # Add keycloak auth data to the conf file so the client can request a token from keycloak
    with open(CONF_FILE, 'a') as cf:
        cf.write("keycloak_url = %(keycloak_url)s\n"
                 "username = %(username)s\n"
                 "password = %(password)s\n"
                 "client_id = %(client_id)s\n" % AUTH_DATA)


@pytest.fixture(scope="function", autouse=False)
def replace_cert_auth():
    # Replace the cert and key file locations in the conf file
    # This allows the _get_cert_auth function to 'work' by using the replacement files instead of the real ones
    for line in fileinput.FileInput(CONF_FILE, inplace=1):
        if line.startswith("cert=") or line.startswith("key="):
            # change the line after cert=/key= to be the replacement file
            line = line[:line.index('=')+1] + TEST_CERT_KEY_FILE
        print(line)


def mock_get_insights_id():
    # Mock the open call in the get_insights_id function so it returns VALID_INSIGHTS_ID, regardless
    # of whether the machine-id file actually exists or not
    # Done it this way too, mainly so we can see the debug log message produced from calling the real get_insights_id()
    with patch(open_func, mock_open(read_data=VALID_INSIGHTS_ID)):
        return utils.get_insights_id()


class TestCRCFunctions:
    """
    Functions for testing operations related to, and interactions with, console.redhat.com
    """
    def test_reading_insights_id_file(self, caplog):
        # Using the mock_get_insights_id function, call the real get_insights_id() function
        # to read the real /etc/insights-client/machine-id file and get the debug log message,
        # but return a different value (ie VALID_INSIGHTS_ID)
        with patch('malware_detection_client.get_insights_id', new=mock_get_insights_id):
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, debug=True)
        assert "Obtained insights_id value '%s' from '%s'" % (VALID_INSIGHTS_ID, utils.INSIGHTS_ID_FILE) in caplog.text
        assert mdc.insights_id == VALID_INSIGHTS_ID

        # Test a missing insights_id file to simulate a system not being registered
        # Patch the INSIGHTS_ID_FILE value so it points to a non-existent file
        caplog.clear()
        with pytest.raises(SystemExit) as exc_info:
            with patch('malware_detection_client.utils.INSIGHTS_ID_FILE', new='/etc/insights-client/machineid'):
                MalwareDetectionClient(conf_file=CONF_FILE, debug=True)
        assert "ERROR:Error reading '/etc/insights-client/machineid' to obtain the insightsId" in caplog.text
        assert exc_info.value.code == 1

    @responses.activate
    def test_upload_host_scan(self, replace_cert_auth, caplog):
        # Now testing all the way through uploading a host scan to console.redhat.com - expected to work ok
        with patch('malware_detection_client.get_insights_id', return_value=VALID_INSIGHTS_ID):
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, rules_location=CRC_RULE_URL, scan_entity=TEST_NETWORK,
                                         results_url=CRC_URL, debug=True)
        mdc.scan_filesystem()
        assert "INFO:Scanning files in '%s' ..." % tld(TEST_NETWORK) in caplog.text
        mdc.upload_host_scan()
        assert 'insightsId: "%s"' % VALID_INSIGHTS_ID in mdc.host_scan_mutation
        assert 'INFO:Uploading scan results of %d matches to %s' % (mdc.matches, CRC_URL) in caplog.text
        assert 'insightsId: "%s"' % VALID_INSIGHTS_ID in caplog.text
        assert 'INFO:Scan results uploaded successfully' in caplog.text

    @responses.activate
    def test_upload_host_scan_invalid_insights_id(self, replace_cert_auth, caplog):
        # An unlikely event now because we check early for an invalid insights_id, but still ...
        # This tests for the error that is produced when trying to upload a host scan with an invalid insights_id
        # To do this we start of with a valid insights_id and swap it for an invalid one before the upload
        with patch('malware_detection_client.get_insights_id', return_value=VALID_INSIGHTS_ID):
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, rules_location=CRC_RULE_URL, scan_entity=TEST_NETWORK,
                                         results_url=CRC_URL, debug=True)
        mdc.scan_filesystem()
        mdc.insights_id = INVALID_INSIGHTS_ID
        with pytest.raises(SystemExit) as exc_info:
            mdc.upload_host_scan()
        assert 'insightsId: "%s"' % INVALID_INSIGHTS_ID in mdc.host_scan_mutation
        assert 'INFO:Uploading scan results of %d matches to %s' % (mdc.matches, CRC_URL) in caplog.text
        assert 'insightsId: "%s"' % INVALID_INSIGHTS_ID in caplog.text
        assert 'Uploading results failed: %s.  %s' % (INVALID_ID_ERROR_MESSAGE, INVALID_ID_ERROR_HINT) in caplog.text
        assert exc_info.value.code == 1

        # Set the insights_id to an invalid UUID value - expect exit with error
        caplog.clear()
        mdc.insights_id = 'BAD UUID'
        with pytest.raises(SystemExit) as exc_info:
            mdc.upload_host_scan()
        assert 'insightsId: "%s"' % 'BAD UUID' in mdc.host_scan_mutation
        assert 'INFO:Uploading scan results of %d matches to %s' % (mdc.matches, CRC_URL) in caplog.text
        assert 'insightsId: "%s"' % 'BAD UUID' in caplog.text
        # assert 'Uploading results failed: %s.  %s' % (INVALID_ID_ERROR_MESSAGE, INVALID_ID_ERROR_HINT) in caplog.text
        assert exc_info.value.code == 1

    @responses.activate
    def test_no_upload_option(self, replace_cert_auth, caplog):
        # Testing the no_upload option when using console.redhat.com URLs
        # If only the rules_location is console.redhat.com, then we still need cert auth even with no_upload
        # because we need to download the rules from the backend
        with patch('malware_detection_client.get_insights_id', return_value=VALID_INSIGHTS_ID):
            MalwareDetectionClient(conf_file=CONF_FILE, rules_location=CRC_RULE_URL,
                                   results_url=CRC_URL, debug=True, no_upload=True)
        assert "INFO:Scan results will not be uploaded because of --no-upload option" in caplog.text
        assert "DEBUG:Using cert auth ..." in caplog.text

        # However if only results_location is console.redhat.com, then we don't need cert auth with no_upload because
        # we don't need to contact the backend at all
        caplog.clear()
        MalwareDetectionClient(conf_file=CONF_FILE, results_url=CRC_URL, debug=True, no_upload=True)
        assert "INFO:Scan results will not be uploaded because of --no-upload option" in caplog.text
        assert "DEBUG:Using cert auth ..." not in caplog.text

    def test_failed_cert_auth_file_access(self, caplog):
        # Trying to access the real /etc/pki/consumer/cert.pem and key.pem files for cert auth
        # Either the cert/key files won't exist (eg in Travis CI test env), or we won't have permission because
        # the tests run as non-root and these files are readable only by root
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient(conf_file=CONF_FILE, results_url=CRC_URL, debug=True)
        assert "DEBUG:Using cert auth ..." in caplog.text
        assert "ERROR:Unable to read certificate file '/etc/pki/consumer/cert.pem'" in caplog.text
        assert exc_info.value.code == 1

        # Remove the cert line from the file, so only the key= line remains
        for line in fileinput.FileInput(CONF_FILE, inplace=1):
            if line.startswith("cert="):
                continue
            print(line)

        caplog.clear()
        with pytest.raises(SystemExit) as exc_info:
            MalwareDetectionClient(conf_file=CONF_FILE, results_url=CRC_URL, debug=True)
        assert "DEBUG:Using cert auth ..." in caplog.text
        assert "ERROR:No certificate and/or key file specified for authentication in the configuration file" in caplog.text
        assert exc_info.value.code == 1


class TestNetworkFunctions:

    @responses.activate
    def test_get_jwt_token(self, remove_jwt_token_cache, caplog):
        # No keycloak_url specified so no cookie created
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR)
        mdc._get_jwt_token()
        assert mdc.session.cookies == {}

        # Try to get token with missing auth params - expect error message and exit
        with open(CONF_FILE, 'a') as cf:
            cf.write("keycloak_url = %s\n" % AUTH_DATA['keycloak_url'])
        caplog.clear()
        with pytest.raises(SystemExit) as exc_info:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR)
            mdc._get_jwt_token()
        assert "Missing authentication value for username, password, client_id" in caplog.text
        assert exc_info.value.code == 1

        # Try to get token with missing client_id auth param - still expect error message and exit
        with open(CONF_FILE, 'a') as cf:
            cf.write("username = %s\npassword = %s\n" % (AUTH_DATA['username'], AUTH_DATA['password']))
        caplog.clear()
        with pytest.raises(SystemExit) as exc_info:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR)
            mdc._get_jwt_token()
        assert "Missing authentication value for client_id" in caplog.text
        assert exc_info.value.code == 1

        # All auth tokens supplied - expect response containing JWT cookie
        with open(CONF_FILE, 'a') as cf:
            cf.write("client_id = %s\n" % AUTH_DATA['client_id'])
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR)
        mdc._get_jwt_token()
        assert mdc.session.cookies == {'auth_server': AUTH_DATA['token']['keycloak_url_hash'],
                                       'cs_jwt': AUTH_DATA['token']['id_token'],
                                       'cs_jwt_refresh': AUTH_DATA['token']['refresh_token']}

    @responses.activate
    def test_get_jwt_token_invalid_creds(self, remove_jwt_token_cache, caplog):
        # Create a config with an incorrect keycloak password
        with open(CONF_FILE, 'a') as cf:
            cf.write("keycloak_url = %s\n" % AUTH_DATA['keycloak_url'])
            cf.write("username = %s\npassword = %s\n" % (AUTH_DATA['username'], 'incorrect'))
            cf.write("client_id = %s\n" % AUTH_DATA['client_id'])

        with pytest.raises(SystemExit) as exc_info:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR)
            mdc._get_jwt_token()
        assert "ERROR:401:" in caplog.text
        assert "Invalid user credentials" in caplog.text
        assert exc_info.value.code == 1

    @responses.activate
    def test_expired_jwt_token(self, remove_jwt_token_cache, add_keycloak_auth, caplog):
        # Test for when the locally stored JWT token has expired
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR, debug=True)

        # Initially the token will be saved to a file and it won't be expired (coz its a new token)
        mdc._get_jwt_token()
        assert "DEBUG:Saving JWT token to %s/.config/malware-detection-client/jwt_token_cache" % os.getenv('HOME') in caplog.text
        caplog.clear()
        # Second time through, we find the token file and check the token hasn't expired
        # For our test it will be expired because the one we created had the current timestamp - which is now expired
        mdc._get_jwt_token()
        assert "DEBUG:Locally stored JWT token has expired, requesting a new one" in caplog.text

    @responses.activate
    def test_upload_host_scan(self, caplog):
        # Scan the tests directory & get a list of all the discovered string_data
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR, debug=True)
        mdc.scan_filesystem()
        mdc.upload_host_scan()
        assert 'insightsId: "%s"' % mdc.insights_id in mdc.host_scan_mutation
        assert 'INFO:Scan results uploaded successfully' in caplog.text

        # Get a list of the various string_datas that were found in the scan
        host_scan_string_data = []
        for match in mdc.host_scan:
            host_scan_string_data.extend(set(map(lambda x: x['string_data'], mdc.host_scan[match])))

        # Expect each of the STRING_DATA elements to be in the host_scan string_data fields
        # And for each of them to be JSON encoded in the host_scan_mutation
        for string_data in STRING_DATA:
            assert string_data in host_scan_string_data
            assert json.dumps(string_data) in mdc.host_scan_mutation

        # For completeness, ensure the unencoded STRING_DATA elements aren't in the host_scan_mutation
        for string_data in STRING_DATA[1:]:
            assert string_data not in mdc.host_scan_mutation

    @responses.activate
    def test_no_upload_host_scan(self, caplog):
        # Test scanning with the no_upload option
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_NETWORK, no_upload=True, debug=True)
        assert "INFO:Scan results will not be uploaded because of --no-upload option" in caplog.text
        assert mdc.results_url == RESULTS_URL
        mdc.scan_filesystem()
        mdc.upload_host_scan()
        assert "INFO:Skipping scan results upload because of --no-upload option" in caplog.text

    @responses.activate
    def test_test_option(self, add_keycloak_auth, caplog):
        # Invoke the test option and get the test rule back
        # Then scan the current directory and expect to match src/malware_detection_client/__init__.py
        # Then scan the processes and expect to find this pytest process running the tests
        # But firstly, since we are using a URL for the rules_location, we need to set the conf file
        # so our client will be requesting a token from our simulated keycloak server
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, rules_location="http://127.0.0.1/signatures.yar",
                                     test_option=True)
        assert "Getting the rules from 'http://127.0.0.1/test-rule.yar'" in caplog.text

        mdc.scan_fsobjects = [full('.')]
        mdc.scan_filesystem()
        # Depending on how the test is run, it may or may not match the __init__.py in the ./src directory
        assert "Matched rule TEST_RedHatInsightsMalwareDetection in file" in caplog.text
        rule_match = mdc.host_scan['TEST_RedHatInsightsMalwareDetection']
        assert len(rule_match) == 3
        assert rule_match[0]['source'] == full('./src/malware_detection_client/__init__.py')
        assert rule_match[0]['string_identifier'] == '$s1'
        assert rule_match[0]['string_data'] == 'class MalwareDetectionClient:'
        assert 500 <= rule_match[0]['string_offset'] <= 1000
        metadata = rule_match[0]['metadata']
        assert metadata['source_type'] == 'file'
        assert 'ASCII text executable' in metadata['file_type']
        assert 'charset=us-ascii' in metadata['mime_type']
        assert metadata['md5sum'] == utils.run_cmd(['/usr/bin/md5sum', rule_match[0]['source']]).split()[0]
        assert 25 <= metadata['line_number'] <= 50
        assert metadata['line'] == urlencode('class MalwareDetectionClient:')

        mdc.scan_processes()
        # Depending on how the test is run, it may or may not match the test process
        assert "Matched rule TEST_RedHatInsightsMalwareDetection in process" in caplog.text
        rule_match = mdc.host_scan['TEST_RedHatInsightsMalwareDetection']
        assert len(rule_match) > 3
        assert rule_match[3]['source'] == str(os.getpid())
        assert rule_match[3]['string_identifier'] == '$s1'
        assert rule_match[3]['string_data'] == 'class MalwareDetectionClient:'
        metadata = rule_match[3]['metadata']
        assert metadata['source_type'] == 'process'
        assert 'python' in metadata['process_name']

        mdc.upload_host_scan()
        assert "INFO:Test scan results uploaded successfully.  Note that test scan results will not appear in the UI" in caplog.text

    @responses.activate
    def test_test_rule_location_urls(self, add_keycloak_auth, caplog):
        # Invoke the test option and (simulate) successfully getting test-rule.yar back from these URLs
        for rules_location_suffix in ['api/malware-client/v1/signatures.yar', 'rules/not-test-rule.yar', '/', '']:
            rules_location = "http://127.0.0.1/" + rules_location_suffix
            test_rule_location = MalwareDetectionClient._get_test_rule_location(rules_location)
            responses.add_callback(responses.GET, test_rule_location, callback=simulate_rule_response)
            MalwareDetectionClient(conf_file=CONF_FILE, rules_location=rules_location, test_option=True)
            assert "Getting the rules from '%s'" % test_rule_location in caplog.text
            caplog.clear()

        # These URLs should 'work' too with our callback function
        for rules_location in ["http://localhost", "https://www.redhat.com"]:
            test_rule_location = MalwareDetectionClient._get_test_rule_location(rules_location)
            responses.add_callback(responses.GET, test_rule_location, callback=simulate_rule_response)
            MalwareDetectionClient(conf_file=CONF_FILE, rules_location=rules_location, test_option=True)
            assert "Getting the rules from '%s'" % test_rule_location in caplog.text
            caplog.clear()

    @responses.activate
    def test_test_rule_location_files(self, add_keycloak_auth, caplog):
        # Save the rules file to /tmp/temp-rule.yar first
        MalwareDetectionClient(conf_file=CONF_FILE, rules_location="http://127.0.0.1/",
                               saved_rules_file='/tmp/test-rule.yar', test_option=True)
        assert "Getting the rules from 'http://127.0.0.1/test-rule.yar'" in caplog.text
        assert "Saving rules to /tmp/test-rule.yar"
        caplog.clear()

        # These filesystem rules_locations will all work for test-rule.yar because it exists in /tmp
        for rules_location in ['/tmp', '/tmp/', '/tmp/signatures.yar']:
            test_rule_location = MalwareDetectionClient._get_test_rule_location(rules_location)
            MalwareDetectionClient(conf_file=CONF_FILE, rules_location=rules_location,
                                   test_option=True, no_upload=True)
            assert "Getting the rules from '%s'" % test_rule_location in caplog.text
            caplog.clear()

        # These won't work though because test-rules.yar file doesn't exist in these locations
        for rules_location in ['tmp', 'tmp/', '/', 'test-rule.yar', './test-rule.yar']:
            test_rule_location = MalwareDetectionClient._get_test_rule_location(rules_location)
            with pytest.raises(SystemExit):
                MalwareDetectionClient(conf_file=CONF_FILE, rules_location=rules_location,
                                       test_option=True, no_upload=True)
            assert "Couldn't find rules file '%s'" % full(test_rule_location) in caplog.text
            caplog.clear()

    @responses.activate
    def test_test_rule_saving_and_scanning(self, add_keycloak_auth, caplog):
        # Try saving the rules file as /tmp.  Expect it will fail because its a directory, not a file
        with pytest.raises(SystemExit):
            MalwareDetectionClient(conf_file=CONF_FILE, rules_location="http://127.0.0.1/",
                                   saved_rules_file='/tmp', test_option=True)
        assert "ERROR:Please specify a file name for the saved rules file: '/tmp' is a directory" in caplog.text
        caplog.clear()

        # Try specifying --test and --scan together.  --test will override --scan
        MalwareDetectionClient(conf_file=CONF_FILE, rules_location="http://127.0.0.1/",
                               test_option=True, scan_entity='/tmp')
        assert "INFO:Test option and scan option used together.  Ignoring scan option value '/tmp'" in caplog.text

    @responses.activate
    def test_identity_header(self, remove_jwt_token_cache):
        import base64
        import socket
        # Test to see if the x-rh-identity header is present or not
        # The account_number= field must be in the conf file, otherwise there will be no x-rh-identity header
        # The default conf file doesn't have the account_number option, so expect no x-rh-identity header
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR)
        assert 'x-rh-identity' not in mdc.session.headers

        # Add the account_number option to the conf file and confirm the x-rh-identity header is present
        # The account_number line doesn't exist in the conf file, so add it straight after the proxy_url line
        for line in fileinput.FileInput(CONF_FILE, inplace=1):
            if "proxy_url" in line:
                line = line.replace(line, line + "account_number=123456")
            print(line)

        # Confirm x-rh-identity is in the headers now
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR)
        assert 'x-rh-identity' in mdc.session.headers
        # Check the account_number and system name fields in the x-rh-identity header
        identity = json.loads(base64.b64decode(mdc.session.headers['x-rh-identity']))['identity']
        assert identity['account_number'] == '123456'
        assert identity['system']['cn'] == socket.gethostname()
