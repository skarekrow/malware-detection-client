from malware_detection_client import MalwareDetectionClient
from .constants import *
import pytest
import json
import jwt
from datetime import datetime
import responses
try:
    from urllib.parse import parse_qsl
except ImportError:
    from urlparse import parse_qsl

# The string_data matches we expect to find in the files in this test directory
# Elements [1:] (from the second element onwards) need to be escaped in the mutation before uploading
STRING_DATA = ['MalwareDetectionClient', 'sent"', 'ata_sff\\x00bioset\\x00bond0\\x00cifsd\\x00']

# Test authentication data that is 'sent' to keycloak
# And the token that is 'returned' from keycloak (it's expiry date is set to now, meaning it expires immediately)
AUTH_DATA = {
    'keycloak_url': KEYCLOAK_URL,
    'client_id': 'client',
    'username': 'testing',
    'password': '123',
    'token': {'id_token': jwt.encode(payload=dict(exp=datetime.utcnow()), key=""),  # token expires immediately
              'refresh_token': 'not_currently_used'}
}


def simulate_keycloak_response(request):
    """
    For simulating sending authentication data to the keycloak server
    and its response depending on what was sent
    """
    data = dict(parse_qsl(request.body))
    if any([auth_type for auth_type in ['username', 'password'] if data[auth_type] != AUTH_DATA[auth_type]]):
        # Missing or incorrect username/password in request
        return 401, {}, json.dumps({"error": "invalid_grant", "error_description": "Invalid user credentials"})
    elif data['client_id'] != AUTH_DATA['client_id']:
        # Missing or incorrect client_id in request
        return 400, {}, json.dumps({"error": "unauthorized_client", "error_description": "Invalid client credentials"})
    else:
        return 200, {}, json.dumps(AUTH_DATA['token'])


def simulate_graphql_response(request):
    """
    For simulating sending the host scan mutation to the graphql endpoint and its response
    """
    data = json.loads(request.body)
    for sd in STRING_DATA[1:]:
        assert sd not in data['query']
        assert json.dumps(sd) in data['query']
    return 200, {}, json.dumps({'recordHostScan': {'success': True}})


@pytest.fixture(scope="function", autouse=True)
def setup_responses():
    """
    Fake the sending of requests to these URLs and instead, call the callback functions
    """
    responses.add_callback(responses.POST, KEYCLOAK_URL, callback=simulate_keycloak_response)
    responses.add_callback(responses.POST, RESULTS_URL, callback=simulate_graphql_response)


class TestNetworkFunctions:

    @responses.activate
    def test_get_jwt_token(self, remove_jwt_token_cache, caplog):
        # No keycloak_url specified so no cookie created
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR)
        mdc._get_jwt_token()
        assert mdc.session.cookies == {}

        # Try to get token with missing auth params - expect error message and exit
        with open(CONF_FILE, 'a') as cf:
            cf.write("keycloak_url = %s\n" % AUTH_DATA['keycloak_url'])
        caplog.clear()
        with pytest.raises(SystemExit) as exc_info:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR)
            mdc._get_jwt_token()
        assert "Missing authentication value for username, password, client_id" in caplog.text
        assert exc_info.value.code == 1

        # Try to get token with missing client_id auth param - still expect error message and exit
        with open(CONF_FILE, 'a') as cf:
            cf.write("username = %s\npassword = %s\n" % (AUTH_DATA['username'], AUTH_DATA['password']))
        caplog.clear()
        with pytest.raises(SystemExit) as exc_info:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR)
            mdc._get_jwt_token()
        assert "Missing authentication value for client_id" in caplog.text
        assert exc_info.value.code == 1

        # All auth tokens supplied - expect response containing JWT cookie
        with open(CONF_FILE, 'a') as cf:
            cf.write("client_id = %s\n" % AUTH_DATA['client_id'])
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR)
        mdc._get_jwt_token()
        assert mdc.session.cookies == {'cs_jwt': AUTH_DATA['token']['id_token'],
                                       'cs_jwt_refresh': AUTH_DATA['token']['refresh_token']}

    @responses.activate
    def test_get_jwt_token_invalid_creds(self, remove_jwt_token_cache, caplog):
        # Create a config with an incorrect keycloak password
        with open(CONF_FILE, 'a') as cf:
            cf.write("keycloak_url = %s\n" % AUTH_DATA['keycloak_url'])
            cf.write("username = %s\npassword = %s\n" % (AUTH_DATA['username'], 'incorrect'))
            cf.write("client_id = %s\n" % AUTH_DATA['client_id'])

        with pytest.raises(SystemExit) as exc_info:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR)
            mdc._get_jwt_token()
        assert "ERROR:401:" in caplog.text
        assert "Invalid user credentials" in caplog.text
        assert exc_info.value.code == 1

    @responses.activate
    def test_expired_jwt_token(self, remove_jwt_token_cache, caplog):
        # Test for when the locally stored JWT token has expired
        # Firstly, setup the conf file so our client will be requesting a token from keycloak
        with open(CONF_FILE, 'a') as cf:
            cf.write("keycloak_url = %(keycloak_url)s\n"
                     "username = %(username)s\n"
                     "password = %(password)s\n"
                     "client_id = %(client_id)s\n" % AUTH_DATA)
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR, debug=True)

        # Initially the token will be saved to a file and it won't be expired (coz its a new token)
        mdc._get_jwt_token()
        assert "DEBUG:Saving JWT token to /home/mhuth/.config/malware-detection-client/jwt_token_cache" in caplog.text
        caplog.clear()
        # Second time through, we find the token file and check the token hasn't expired
        # For our test it will be expired because the one we created had the current timestamp - which is now expired
        mdc._get_jwt_token()
        assert "DEBUG:Locally stored JWT token has expired, requesting a new one" in caplog.text

    @responses.activate
    def test_upload_host_scan(self):
        # Scan the tests directory & get a list of all the discovered string_data
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR)
        mdc.scan_filesystem()
        mdc.upload_host_scan()

        # Get a list of the various string_datas that were found in the scan
        host_scan_string_data = []
        for match in mdc.host_scan:
            host_scan_string_data.extend(set(map(lambda x: x['string_data'], mdc.host_scan[match])))

        # Expect each of the STRING_DATA elements to be in the host_scan string_data fields
        # And for each of them to be JSON encoded in the host_scan_mutation
        for string_data in STRING_DATA:
            assert string_data in host_scan_string_data
            assert json.dumps(string_data) in mdc.host_scan_mutation

        # For completeness, ensure the unencoded STRING_DATA elements aren't in the host_scan_mutation
        for string_data in STRING_DATA[1:]:
            assert string_data not in mdc.host_scan_mutation

    @responses.activate
    def test_no_upload_host_scan(self, caplog):
        # Test scanning with the no_upload option
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_DIR, no_upload=True, debug=True)
        assert "INFO:Scan results will not be uploaded because of --no-upload option" in caplog.text
        assert mdc.results_url == RESULTS_URL
        mdc.scan_filesystem()
        mdc.upload_host_scan()
        assert "INFO:Skipping scan results upload because of --no-upload option" in caplog.text
