import json
import unittest2
import responses
try:
    from urllib.parse import parse_qsl
except ImportError:
    from urlparse import parse_qsl
from malware_detection_client import MalwareDetectionClient
from test_constants import *


STRING_DATA = [' MalwareDetectionClient', ' sent"', ' ata_sff\\x00bioset\\x00bond0\\x00cifsd\\x00']

AUTH_DATA = {
    'keycloak_url': TEST_KEYCLOAK_URL,
    'client_id': 'client',
    'username': 'testing',
    'password': '123',
    'token': {'id_token': 'abc123', 'refresh_token': 'xyz789'}
}


def get_token(request):
    data = dict(parse_qsl(request.body))
    if any([auth_type for auth_type in ['username', 'password'] if data[auth_type] != AUTH_DATA[auth_type]]):
        return 401, {}, json.dumps({"error": "invalid_grant", "error_description": "Invalid user credentials"})
    elif data['client_id'] != AUTH_DATA['client_id']:
        return 400, {}, json.dumps({"error": "unauthorized_client", "error_description": "Invalid client credentials"})
    else:
        return 200, {}, json.dumps(AUTH_DATA['token'])


def do_upload(request):
    data = json.loads(request.body)
    for sd in STRING_DATA[1:]:
        assert sd not in data['query']
        assert json.dumps(sd) in data['query']
    return 200, {}, json.dumps({'recordHostScan': {'success': True}})


class TestNetworkFunctions(unittest2.TestCase):

    def setUp(self):
        # Create conf file to be used throughout the tests
        remove_conf_file()
        with self.assertRaises(SystemExit):
            MalwareDetectionClient(create_conf=True, conf_file=CONF_FILE, **LOCATION_PARAMS)
        responses.add_callback(responses.POST, TEST_KEYCLOAK_URL, callback=get_token)
        responses.add_callback(responses.POST, TEST_RESULTS_URL, callback=do_upload)

    def tearDown(self):
        remove_conf_file()

    @responses.activate
    def test_get_jwt_token(self):
        # No keycloak_url specified so no cookie created
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_PREFIX)
        mdc.get_jwt_token()
        self.assertEqual(mdc.cookie, {})

        # Try to get token with missing auth params - expect error message and exit
        with open(CONF_FILE, 'a') as cf:
            cf.write("keycloak_url = %s\n" % AUTH_DATA['keycloak_url'])
        with self.assertRaises(SystemExit) as exc, self.assertLogs() as logs:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_PREFIX)
            mdc.get_jwt_token()
        self.assertIn("ERROR:malware_detection_client:Missing authentication value for username, password, client_id",
                      logs.output)
        self.assertEqual(exc.exception.code, 1)

        # Try to get token with missing client_id auth param - still expect error message and exit
        with open(CONF_FILE, 'a') as cf:
            cf.write("username = %s\npassword = %s\n" % (AUTH_DATA['username'], AUTH_DATA['password']))
        with self.assertRaises(SystemExit) as exc, self.assertLogs() as logs:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_PREFIX)
            mdc.get_jwt_token()
        self.assertIn("ERROR:malware_detection_client:Missing authentication value for client_id", logs.output)
        self.assertEqual(exc.exception.code, 1)

        # All auth tokens supplied - expect response containing JWT cookie
        with open(CONF_FILE, 'a') as cf:
            cf.write("client_id = %s\n" % AUTH_DATA['client_id'])
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_PREFIX)
        mdc.get_jwt_token()
        self.assertEqual(mdc.cookie, {'cs_jwt': AUTH_DATA['token']['id_token'],
                                      'cs_jwt_refresh': AUTH_DATA['token']['refresh_token']})

    @responses.activate
    def test_get_jwt_token_invalid_creds(self):
        with open(CONF_FILE, 'a') as cf:
            cf.write("keycloak_url = %s\n" % AUTH_DATA['keycloak_url'])
            cf.write("username = %s\npassword = %s\n" % (AUTH_DATA['username'], 'incorrect'))
            cf.write("client_id = %s\n" % AUTH_DATA['client_id'])

        with self.assertRaises(SystemExit) as exc, self.assertLogs() as logs:
            mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_PREFIX)
            mdc.get_jwt_token()
        self.assertIn("ERROR:malware_detection_client:401", " ".join(logs.output))
        self.assertEqual(exc.exception.code, 1)

    @responses.activate
    def test_upload_host_scan(self):
        # Scan the tests directory & get a list of all the discovered string_data
        mdc = MalwareDetectionClient(conf_file=CONF_FILE, scan_entity=TEST_PREFIX)
        mdc.scan_filesystem()
        mdc.upload_host_scan()
        host_scan_string_data = []
        for match in mdc.host_scan:
            host_scan_string_data.extend(set(map(lambda x: x['string_data'], mdc.host_scan[match])))

        # Expect each of teh string_data elements to be in the host_scan string_data fields
        # And to be JSON encoded in the host_scan_mutation
        for sd in STRING_DATA:
            self.assertIn(sd, host_scan_string_data)
            self.assertIn(json.dumps(sd), mdc.host_scan_mutation)

        # Make sure the unencoded string_data isn't in the host_scan_mutation
        for sd in STRING_DATA[1:]:
            self.assertNotIn(sd, mdc.host_scan_mutation)


if __name__ == '__main__':
    unittest2.main()
